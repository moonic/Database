# Database System concepts 
> 对数据 存储管理 处理和维护的软件系统

* Database Mangement System DBMS
	* 关联的数据集合好一组访问数据的程序组成
	* 提供发布高校的存储数据项信息的途径
	* 信息的存储结构定义 安全保证 避免异常产生

 
* File Save Data
	* 数据杂糅不一致
		* 同种信息 无法分辨 同名等
	* 数据访问困难
		* 新的需求增加 功能列表 如何访问
	* 数据孤立 
		* 数据分散不同文件中 格式不同
	* 完整性
		* 数据的每个值都满足特定的约束
	* 原子性
		* 银行的存储 账户永远不为零 
	* 并发访问异常
		* 一个行为同时并发进行
	* 安全性
		* 数据存储的安全性访问，并不能访问所有数据


* Data View
	* 相互关联的数据组成一组用户可以访问修改的数据集合

* Data override
> 可用的系统必能高效的检查数据 简化用户的操作

* 物理层
	* 数据是如何存储
* 逻辑层
	* 数据存储什么数据 存在如何的关系 保护数据的独立性
* 视图层
	* 提供用户访问数据的交互视图


 type instruclor = record
 	ID : char(5)
 	Name : char(5)
 	Dept_name : char(5)	
 	salary : number(8,2)
 	end;

* 定义了了4个字段记录 每个字段记录有一个字段名所属的类型
	* deotment Dept_name buidding budget

* 物理层
	* 一个字段的记录可以被描述层联系存储组成的存储块
* 逻辑层
	* 记录间的相互关系
* 视图层
	* 一组应用程序

---


## 实列和模式
> 时间的推移 信息被插入删除 存储在数据库中的称为 实列
数据库总设计成为数据库模式 不同层在不同模式下的设计成为


* Data Model
> 描述 数据 联系 语言 以及 一致性元素概念工具的集合

* 关系模型
	* 表的集合来表示数据和数据间的关系
	* 基于记录模型的一种

* 实体 联系模式 E-R
	* 实体基本对象以及对象构成
	* 对象的以及是区或者一个问题
	* 用于数据库设计

* 对象的数据模型
	* 面向对象数据模型
	* E-R模式 增加封装方法 还是对象表示等标识概念扩展

* 半结构化数据模型
	* 运行系统数据类型的数据项含不同属性集的定义
	* xml 被广泛的表示

* 数据库语言
	* 数据库系统提供的语言来定义数据库模式 以及数据操作系统鱼鱼
	* 操纵语言 DML
		* 查询 select *from name
		* 插入 insert into table_name values()
		* 修改 delete from table_name xx where 
  * 过程化DML  指定数据以及如何获得数据
	* 声明化     用户知道数据但是不申明
* 数据定义语言 DDL
	* 数据存储定义
	* 满足一致性约束
		* 成约束 
			* 每个属性对弈一个肯的取值构成的成
		* 参照完整性
			* 关系给定属性集上的取值存在
		* 断言
			* 成约束是断言的特殊形形式
		* 授权
			* 不同的用户在数据库中的数值运行不同访问类型
			* 读授权 修改授权 更新授权

* 关系型数据库
> 关系型模型 包括数据操作语言 SQL语言

* 表
	* 每个表有多个实列 每个列有唯一的名字
	* 关系型模型是纪律模型的一个实列
	* 结构固定格式id记录 每个表一种特定类的记录

* 来自应用程序的数据访问 （DML由宿主入）
	* 提供的程序接口 取回结果
	* 扩展宿主 衣服 嵌入DML调用 DML 预编译器


### 数据库设计
>管理大量信息，作为企业行为的一部分 提供信息服务

* 设计过程
	* 选择数据模型 概念设计
		* 包括哪些数据 如何组织到表存放到表中
	* 功能性说明 
		* 数据上的各种事务  功能满足需求
	* 逻辑设计模型 
		* 映射到数据模型上用于特定是为了设计模式

* 实体联系模型 E-R
	* 通过实体数学集合来描述
	* 各个实体之间的联系
* 规划化
	* 生成关系模式集合 存储信息不必要杂糅能心意的搜索数据
		* 适当的范式模式 函数依赖
---


## 数据存储和查询
> 数据库分成不同的模块 每个模块完成一个功能 分成存储管理器
和查询处理部件


* 存储管理器
	* 权限以及完整性管理
		* 是否完整约束 用户权限
	* 事务管理器
		* 事务一致性
	* 文件管理器
		* 磁盘的空间分配
	* 缓存管理器
		* 磁盘读取到内存 那些数据缓存到内存中
	* 数据文件
		* 存储数据本身
	* 数据字典
		* 数据库结构元数据 数据库模式
	* 索引
		* 数据项快速访问

* 事务管理
	* 原子性 一致性 持久性
	* 完成单一逻辑功能的操作集合

* 数据挖掘与信息检查
	* 数据文件 不知道分析大型数据库并从中找出有用的模式过程
	也成为集群学习 统计分析 从数据寻找规则和模式
	* 可以已知信息变量来预测输出
	* 数据处理编程时候算法的格式 找到新奇有用的模式 给定一个数据库
	* 商业使用连接数据来支持对业务更好的决策
	* 大型企业的不同决策要在各种不同的数据上高数的执行查询
	建立了 数据仓库 多个来源收集数据激励统一的模式
	* 文本数据爆炸的增长（和关系数据库中结构化数据的不同） 信息检查也车位

* 特种数据库
	* 应用领域受到关系模型的限制 开发了 数据模型来处理这些领域的问题

* 基于对象的数据库
	* 面向对象程序设计 导致面向数据模型的在
	* E-R的扩展 增加了 封装 方法 函数对象的表示 对象便和信息封装
	* 对象 关系数据模型 扩展了关系模型


* 半结构化数据模型
	* 允许系统数据有不同属性数据的说明 
	* xml语言的设计 为了文本数据增加标签信息

* 习题
	* 数据库的优点不足
		* 数据库用来存储 操作 维护 数据 
		* 设计的时候抽象 物理 逻辑 视图层 让用户更好的操作数据
---


# 关系模型
> 商用数据处理成为主要的数据模型 简化了编程的工作

* 关系数据库的结构
	* 表的集合组成 每个表有唯一的名字
	* 关系用来代指表 元组代指行 属性 是列
	* 用关系实列来表示关系的特定行
	* 对于关系的属性存在一个存取值的集合成为该属性的（域）
	* null是一个特殊值

* 数据库模式
> 数据库模式是数据库的逻辑设置，数据库实例是数据库中的快照

* department(Dept_name,building,budget)
	* 关系模式是将不同的关系元祖联系在一起的方法
	* 就是表的 标的

* 码 key 
	* 区分关系不同元组的方法，使用属性来说明
	* 一个元祖的属性必须唯一 区分元元组的
	*一个关系没有二个元组所在的属性上取值相同

* 超码 superkey
	* 一个欧多属性的集合 唯一标识元码
	* 列如 instructor的ID属性可以区分元组
	* ID 和name是组合关系 instructor一个超码 最小超码称为后选码

* 主码 primary key
	* 必须作为唯一区分
	* 从不 极少变换的值
	* 参照完整性约束 referential integrity constraint

* 关系模式 家里在表的集合基础上 对表进行查询 插入元组修改更新元组
* 关系的超码是一个 数学的集合 取值保证唯一失败
* 模式图 数据库关联关系的图形化表示

--- 

# SQL语言
> IBM开发的叫做sequel发展到现在 结构化化查询语言
ISO 发布标准 

* 组成部分
	* 数据定语语言 DDL
		* 定义关系模式 删除修改的命令
	* 数据操作语言 DML
		* 查询信息 插入元组 删除 修改元组的能力
	* 完整性
		* 定义的完整性的约束
	* 视图定义
		* DLL包括定义视图的命令
	* 事务控制
		* 开始 结束事务的命令
	* 嵌入式SQL 动态SQL
		* 如何嵌入通用编程语言
	* 授权
		* 对视图的访问权限命令

* SQL 数据定义
	* 每个关系模式
	* 每个属性的取值
	* 完整性约束
	* 关系维护的索引集合
	* 关系的安全权限信息
	* 关系物理存储

* DML
	* insert 将数据插入到关系中去
	* delete 删除元组
	* drop 除去关系
	* alter 增加 属性

* 事务
	* 查询或更新语句的序列组成 
		* commit work 提交当前事务
		* rollback work 回滚
* 完整性约束
	* not null 非空
	* unique
	* check 谓词
	* primary key 主键约束
	* 外键约束

* from定义在句子的笛卡尔积 使用集合理论来定义
* 迭代过程来理解 from 字句结果关系产生的元组
for each 元组 t in 关系 r1
	for each 元组 t2 in 关系 r2

		* distinct 出去重复 
		* all 显示不出去重复
		* join  自然连接

--- 

## 关系代数
> 过程化长训语言 包括一个运算的集合 以关系为输入产生新关系作为结果

* 关系代数的运输分为
	* 基本运算
	* 附加运算
	* 扩展运算

* 关系的基本运算结果有
	* 选择 投影 并 集合差 笛卡尔积 更名
	* 其他运算
		* 集合教 自然选择和复制

* 基本运算
	* 选择 投影 更名 称为一元运算 对一个关系进行运算

* 选择 select 满足给定为谓词的元组 sigma（α）表示选择
	参数关系 α 括号中 
	* 选择关系 instructor 中联系元组 写作
		* αdept_name = physics(instructor)

* 投影运算
	* 假如累出所有 ID name salary 不关系 Dept_name 
		* π_ID,name,salary (instructor)
	* 关系集合运算
		* Π_name (α_dept_name = physics(instructor))
	* 将关系代数组合成关系代数表达式
		* 如同算数表达式 + - 组合一样

* 并运算 r∪s
	* 关系必须同元 属性数目相同
	* 对于 i，r 属性域 必须和 s的i个 属性相同

* 集合差运算 -
	* 相融的关系运算
	* 关系必须同元 属性相同

* 笛卡尔积运算 r1xr2 
	*  提出命名机制来区别属性的关系 附加在属性上
		* α_dept_name = phyiscs - (instructor x teaches)
	* 将 instructor 元组 和 teaches 元组 属性联系

* 更名运算
	* 关系代数表达式结果是没有引用的名字 
		* ρ_x（A1,A2,...A_n）

* 关系代数的形式化定义
	* 数据库中的一个关系
	* 常量关系
	* 交 并 补 差 积

* 扩展关系代数运算
	* 广义投影
		* 投影列表使用算数运输费 函数等进行扩展
		* π_F1,F2...Fn(E)
	* 聚集
		* 聚集函数 
			* 输入值一个汇集 使用对值集合使用
				* sum 汇聚 {1,1,3,4,4,11}
			* 多重集
				* 同一个值出现多次

## 元组关系演算
> 写关系代数表达式 产生了查询你结果过程序列 能生成查询答案
元组关系是非过程化的查询语言 只描述信息 不给出过程

* 查询实列
	* 工资 8000 以上的 ID name Dept_name salary
		* 只需要ID的属性 不是关系所有的属性 使用元组演算

* 表达式的安全问题
	* 元组运算表达可能产生一个无限的关系
		* 为了对元组关系进行限制 引入了元组关系式 P的域
--- 


## 数据库设计
> 构建一个数据库 包括设计数据库模式 访问更新的程序 
已经数据访问的安全模式 用户在需求设计扮演一个中心角色
主要描述数据库模式设计

* 设计选择
	* 杂糅
		* 重复信息存储 信息的拷贝会变的不一致
	* 完整性
		* 实体中没有对应的关系 如何设计

* 实体-联系模式 E-R Model
> 代表数据库去哪聚逻辑结果的企业模式实现的

* 实体集
	* 实体
		* 可区别所用其他对象的事务 或者 对象 使用唯一标识
	* 相同类型具有相同性质的实体集合
		* 实体集不必互不想交
	* 通过一组属性来表示 每个属性都有确定的值

* 联系集
	* 联系 多个实体的相互关联
	* 联系集 相同类型类型的集合 n>=2 实体集合上的数字关系
	* 实体集 之间的管理称为参与
		* 联系实例 命名实体同一个关联
	* 联系也具有描述性 实体与属性相联系起来
	* 作为联系描述属性的列子 考虑实体student section参加的联系集
	  可以用一个数学来记录学生的到课率
	* 给定联系必须是参与实体表示的 不必使用描述属性
		列子 一个教室作为特定学生导师日期建模 使用参与实体是无法
		唯一标识的
	* 二元联系 
		* 大学开展实体联系集 project 有多个学生老师参加
		* 参与实体集的数目成为联系集的度 degree 二元为2
* 属性
	* 每个属性有一个可取值的集合成为 属性的域 或者值集
	可以是特定长度所用文本字符串的集合 
	* 实体集的属性是将实体映射到域的函数 一个实体有多个属性
	每个时下可用一组 属性 数据值来表示

* E-R模型属性划分
	* 简单的复合属性 简单时下不能被划分成更小的部分
		* 复合属性能划分成更小的部分 (其他属性)
		* 复合属性可以有层次的 多次分拆
	* 单值和多值属性 一个特定实体只有单独的值
		* 单值 对特定的学生实体一个Student_ID独一一个ID
		* 多值 不同的教室有不同数量的电话
	* 派生属性 从别的关系实体派生出来 教师实体有属性表示指导多少学生
	可以通过统计学生实体 数目来得到这个关系

* 约束
	* 映射基数约束 实体通过类型集关联的实体个数
		* 一对一 
		* 一对多
		* 多对多
	* 参与约束
		* 实体都参与到联系集的至少一个联系中
			* 实体集 在联系集中的参与成为 全部的
			* 参与只是部分的称为部分参与集
	* 码
		* 区分实体集中的实体 各个实体是互异的，必须通过属性证明
		* 码直接使用于实体集 区分属性
		* 如果联系集合没有属性关联 你们属性集合∪的联系构成超码
* 实体联系图
	* 表示数据库的全图逻辑
	* 设计问题
		* 新增加的属性和实体集 是用属性还是用实体
		* 对象被描述为实体集还是联系集 并不是容易的
			用实体集还是联系集
		* 父母有一个孩子 可以记录母亲而不知道父亲 二元还是n元联系集

* 扩展的E-R特性
	* 特化
		* 实体集包含子集的实体区别实体集的其他实体
			* 实体集的 persion 
				* employee
				* student
		* 实体集是否可以是于多个特化实体集必须特化一个
		成为重叠特化 后者称为不持久特化
	* 概化
		* 实体集到不同层次的实体子集细化代表 自顶向上进行
		* 多个共同特征综合成高层实体集合 开始标识
		* 高层与低层的实体集被称作超类 和子类
			* persion 与 employee student
* 属性的继承
	* 特化和概化产生的特性是属性的继承
	* 高层实体的关联所用属性适用于低层实体
	* 底层实体特有的性质适用于特定实体集

* 概化的约束
	* 条件定义的 
		* 在条件定义的低层实体 成语之歌确定基于实体是否满足特定的条件与谓词
	* 用户定义 
		*用户定义的低层实体表示通过成语资格来限制的数据库用户实体派个实体集
	* 不想交 
		* 不想交约束要求一个实体至多一个低层实体集
	* 重叠 
		* 通过实体同时属于一个概化多个低层实体集
	* 聚集
		* 联系集属性可以合并到联系集中
---

## 关系数据库设计
> 如何生成一组关系模式 满足实弹的设计范式

* 更大的模式
	* instructor deptartment 对弈的关系进行自然连接的结果
	* 元组的预算数据统一 每个预存数据存储一次
	* 无法直角表示一个实体的信息 

* 更小的模式
	* 发现实体的属性的信息重复 分成更小的设计模式
	* 观察导出的规则(函数依赖)模式 找到正确的分解
	* 利用分组插常生的元组 有损分解 无损分解 

* 原子域和NF1
	* E-R模式 运行实体的连续集的属性具有程度的子结构
	* 但是设计表的时候消除子结构对 于组合的每个指数下作为本身属性
	* 多值属性每个项创建一条元组

* 一个域是原子的 该域不可分成为NF1

* 使用函数依赖继续分解 (关系是否该分解 基于函数依赖的概念)
	* 关系模式是一个属性集 并非属性是模式
	* 属性是超码 特殊关系模式

* 码和函数依赖
	* 实体建立模式 数据存在各种约束
	* 实体的约束转化 成码，或者定义的函数依赖
		* 判定关系的实例是否函数依赖集
		* 合法关系集 上的约束那些关系实例

* Boyce-Codd NF
	* 消除基于函数依赖的杂糅
		* a -->b 是函数依赖
		* a是 模式R的超码
	* 构成giant设计模式的关系集合中每个模式属于BCNF
	* 关系二方属于属性的函数依赖
	* 一般规则 a-->b a不是b的超码
		* a∪b
		* (R - (b-a) )
	* 最后保持BNCF模式的集合
* BCNF 和保持依赖
	* 在有些情况下BCNF的分解会导致函数依赖的高效检查
		* 大学课程为多对一提出 但是教师只能是的单个关联
		* 设计为实体联系依赖
* 第三范式
	* BCNF 平凡依赖如 a-->b a为一个超码
	* 具有函数依赖的 模式属于第三范式
	* 某些 BCNF  不允许俄的函数迎来 在3NF是允许的

* 函数依赖理论
	* 函数依赖集的闭包
		* 定义模式上的函数依赖集在其他函数模式上也存在
		称这些函数依赖 F逻辑蕴含

* 逻辑蕴含的函数依据
	* 自反律 b∈a a-->b
	* 增补律 a-->b 成立 为r的属性集 ra-->rb成立
	* 传递律 a-->b b-->r 成立则a-->r
	* 合并律
	* 伪传递律

* 属性的闭包
	* a--->b 称为属性b被a函数确定(functionally determine)
	* 集合a是否为超码 计算a函数的属性值
		* resul:= a;
			repeat
				for echo 函数依赖 b-->in F do
					begin
						if b∈resul then resul := resul∪r;
					end
				untll (resul不变)

* 正则覆盖
	* 关系模式上有函数依赖F在关系执行更新 保证不破坏任何函数依赖
	如果破坏了函数依赖 系统必须回滚更新操作
	* 任何函数依赖属性不改变 函数依赖集的闭包则属性是 无关属性
		* A∈a F蕴含 a-->b ∪(a-A)-->b A在a中无关
		* A∈a F蕴含 a-->b ∪a-->(b-A) A在b中无关

* 无损分解
	* 一个关系模式 上的函数依赖 分解关系模式 没有信息损失
	称该分解为无损分解
		* Select * from (select R1 from r) natural join (select R2 from r)
		* π_r1 ↔ π——r2 = r
	r投影到R1和R2上计算投影结果是自然连接 称为有损分解
		* R1 ∩ R2 --> R1 
		* R1 ∩ R2 --> R2

* 分解算法
	* 使用适当的NF设计算法 BCNF 3NF 对应的算法

* BCNF 分解
	* 检查观赏是否属于BCNF F是繁重的任务 描述判定关系
	是否属于 不过不属于能被分解属于的则称为BCNF算法
	* 判定方法
		* 检查 函数依赖是否a-->b违反DCNF 验证R中的所有属性
		* 关系模式R是否属兔DCNF 给检查集合F中的函数依赖是否违反
		* R中属性每个子集a 要么不含一个 要么所有
	* resul := |R|;
		done := false
		count F
		while(not done)do 
			if(resul 中存在R 不属于BCNF)
			then begin
			满足依赖
		end

* 3NF合成算法
	* 依赖R是F的 正则覆盖
	* 一个关系R 是否属于3NF 右半单个属性的函数依赖就足够
	确认R上的函数是否依赖 a-->b B∈R 
		* B属于a 又属于b a-->b不属于F 否则是无关的
		* B属于b 不属于a
			* r是一高超码满足3NF
			* r不是超码 但a包含不存在r的属性
		* B属于a 但不属于b

* BCNF 3NF 比较
	对数据库设计的目标是
	* BCNF
	* 无损
	* 保持依赖

* 不能总是达到这些目标 在这二种算法选择
	* 主码或者唯一约束 申明的特殊情况 SQL不提供函数依赖途径
	* 可以通过写断言来爆出函数依赖
	* 只有一个保持依赖的分机 使用标准的SLQ 对于码的函数依赖进行高效的检查

* 多值依赖分解
	* 有些关系模式属于BCNF 还是存在信息重复的问题
		* 比如 教师有很多关联 很多联系
		* 非BCNF模式 有函数依赖
		* 使用BCNF 分解得到二个模式 可以进一步分解
	* 为了处理这个问题 定义新的约束形式 第4NF

* 4NF
	* 多值依赖 ID-->street city 成立 但是设计并不理想
	可以给定多个值依赖改进数据库的设计 称为4NF
	* 属于4NF的条件是 对D的所有形式形成 a-->b的多值依赖
	只要一个则成立
		* a-->b 是一个平凡依赖
		* a是R的一个超码
	* 4NF定义与BCNF的定义唯一不同存在与多值依赖的使用
	* 4NF一定属于BCNF

* 4NF分解
	* BNCF分解一样就是多值依赖在D 上的R上限定	
		* resul := |R|;
		done := false
		count D 给定模式R 令D表示在R上限定
		while(not done)do 
			if(resul 中存在R 不属于4NF)
			then begin
			a-->b 为R上成立的平凡多值依赖
			a-->R z不属于D 而且 a∩b = ∅
		end
	* 令r(R)为一个关系模式D为R上的函数多值依赖集合
	r1(R1) r2(R2) 为R的一个多值依赖分解
		* R1∩R2--> R1
		* R1∩R2--> R2
* 更多的范式
	* 多值依赖 有助于理解并消除信息的重复
	* 有的约束称为连接依赖 概化了多值依赖
	* 投影-连接范式 称为5NF
	* 域 码范式 DKNF范式

* 数据库的设计过程
	* 给定关系模式 并对之进行规范化
		* r(R) E-R模式转换而成的
		* r(R) 包含所有属性的单个关系
		* r(R) 关系的设计结果

* E-R模式和规范化
	* 实体的属性之间存在函数依赖 大部分联系集二元的
	* 如果式多值依赖成立而不是被相应的函数依赖隐含
		* 一对多的联系集
		* 实体集的一个多值属性
	* 对于多对多的联系集 每个关系有自己的模式存在额外表示
	多值的属性创建一个单独的模式 包含属性的实体集的主码

* 属性和联系命名
	* 数据库设计是唯一的角色假设 每个属性只有唯一的含义
	* 小心的保证每个集合使用正确的 number 使用不同的属性名
	* 不同关系的属性有相同名字的含义 可以设计实体集来

---

## 数据的存储和查询
> 数据必须以比特的形式存储在一个或者多个存储谁被上
大多数存储在磁盘上 越来越多存储在内存上 内存快

### 存储文件结构
> 在概念层或逻辑层上 认为关系模型中的数据库是表的集合
各种数据库的结构适合不同类型的数据访问 数据库的结构依赖于系统
的使用方式和特定机器的物理特性

* 物理存储介质
	* 高数缓存器
		* 最块最贵的存储介质 
		* 数据库系统在设计插叙数据结构算法的适合 
		* 数据库的实现会注意高数缓冲器的影响
	* 主存储器
		* 用于存放可处理的数据存储介质 
		* 对于存储数据库来时还是太小
		* 如果发生系统崩溃 内容全部消失
	* 块闪存存储器
		* 在电源关闭的时候数据可以保存下 NAND NOR 快闪
		* 盖饭的用于USB盘存储数据 设备的通用串行总线
	* 磁盘存储器
		* 长期联机数据存储的主要介质是磁盘
		* 整个数据库存储在磁盘上
		* 为了访问数据 系统将数据从磁盘中移动主存储器 完成操作数据写回磁盘

* 最快存储介质成为基本存储 层次结构中基本存储介质的下一层
被成为辅助存储 或者联机存储 层次结构中最底层的成为三级存储或者 脱机存储
* 不同存储系统处理处理速度成本不同外 还存在存储易失问题
易失性存储 在设备断电后丢失的内容

* 磁盘和快闪存储器
	* 非常大型的数据库需要上百磁盘 块存储存也在增加
	形成磁盘存储的竞争

* RAID
	* web 等的数据增长太快 需要大量的磁盘存储 
	* 为了提供性能的可靠性 提出了独立磁盘冗余陈列(RAID)
	* RAID 有更高的可靠性 执行效率 易于管理操作

* 通过冗余提高可靠性
	* N张磁盘组成的集合 磁盘发生故障比特定一张概率要高
	* 引入冗余 是解决问题的可靠的方法 
	* 可以采取镜像复制引入冗余
* 通过并行提高性能
	* 比特级拆分
		* 多张磁盘上进行数据分析来体用传递效率 使用比特分开
	* 块级拆分
		* 块查封到多张磁盘 阵列看成单独的大磁盘 并给块进行逻辑编号

* 磁盘拆分的目的性
	* 负载平衡多个小的访问操作 提高访问操作的吞吐量
	* 并行执行大的访问操作 减少大访问操作的响应时间

* RAID级别
> 镜像提供了高可靠性 但是昂贵 拆分提供了高的数据传输率 但不提高可靠性 奇偶检验位

* RAID leve 0
	* 拆分没有冗余 
* RAID leve 1
	* 块级别拆分的磁盘镜像
* RAID leve 2
	* 内存风格的纠错码 组织结构使用奇偶验证
* RAID leve 3
	* 位交叉的奇偶检验组织结构
	* 检测一个扇区的破坏 计算其他扇区对应的奇偶值
* RAID leve 4
	* 块交叉奇偶组织结构 
	* 读取一个块只访问一张磁盘 允许其他请求的进行
	* 但是小的读写操作不能并的执行 一个单独的写需要4次磁盘访问
* RAID leve 5
	* 块交叉奇偶组织结构 改进版
	* 所有操作对请求服务

* 级别选择
	* 额外磁盘带来的花费
	* I O操作性能的需求
	* 磁盘故障时候的性能
	* 数据重建过程的性能 

* 文件组织
	* 数据库被映射到多个 不同文件 操作系统维护
	* 文件在逻辑上组织记录为一个序列映射到磁盘块上
	* 被分为定长的存储单元称为块 能记录很多记录 是物理组织形式决定的

* 定长记录
	* ID varchar(5) 容纳的最大字节数量
	* 文件开始分配一定的数量作为文件同步 包各种信息
	* 内容被删除第一个记录的地址 第一个存储第二个可用的地址 
	形成链表
	* 插入新的使用文件指向性的记录

* 变长记录
	* 多中记录在一个文件中存储
	* 允许多个字段是变长的记录类型
	* 重复字段的记录类型
	* 空位图 分槽页结构

* 文件中的记录组织 (关系是记录的集合 给定记录的集合后如何在文件中组织它们)
	* 堆文件组织
		* 一条记录可以存放在任何地方 没有顺序，通常一个关系一个单独文件
	* 顺序文件组织
		* 记录根据搜搜索玛的值存储 
	* 散列文件组织
		* 每条记录的属性上计算一个散列函数 决定记录文件的存放的块
		* 每个关系记录用单独的文件存储在 多表聚簇文件组织中 不同关系存储在相同的块中
* 顺序文件组织 (为了高效的处理索引码的记录而设计的)
	* 通过指针记录连接起来 每条记录按照索引码的排序设计的
	* 索引码是任意一个属性的集合 没有必要是主码 超码

* 多表聚簇文件组织
	* 在每一个块中存储二个或者多个记录文件的结构 运行用一次块的读操作来满足条件
	* 使用可以在查询处理性能提高	
		* 关系的元组可以表示定成的记录 可以映射到简单的文件结构中
		* 大规模的时候 文件管理并不直接依赖下层的操作系统
		数据库把关系存储在这个文件中 子集管理这个文件 之给定一个块管理


* 数据字典存储
> 一个关系数据库维护不关于关系的数据 比如关系的模式
关于数据的数据成为元数据

* 每个关系的属性的名字 属性的和长度
* 定义的视图名字 和视图的定义
* 完整的约束 授权用户的名字
* 关系元组的个数 关系所用的存储方法
* 记录关系的文件名
* 索引名字 被搜影关系的名字 构造索引的类型

* 所有的元数据组成了微信的数据库 用专业的数据结构代码来存储信息

* 数据缓存区
	* 减少磁盘和存储器中间传输的块数目 减少磁盘的服务次数
		* 在主存储器上保存更个多的区块 不需要访问磁盘
		* 主存取中保留所有的块是不可能的更多的可用的空间分配

* 缓存管理器
> 程序调用磁盘上的块的时候调用 如何块在花村器作为主存储器中的地址给缓存区
如果不在 就为这个块腾出新的控价 移出的块作为最近的写入重新分配空间
	* 缓存区替换策略
		* 缓存区没有剩余空间 新块读缓存区移除 最近少用的策略
	* 被盯住的块
		* 为了从系统崩溃中恢复 限制块写入磁盘的块
	* 块的强制写出
		* 不需要一个块占用的缓空间 必须写回磁盘

---

## 散列与索引
> 与文件相关联的附加结构

* 索引
	* 顺序索引
		* 基于值的顺序排序
	* 散列索引 
		* 将值平均分配到散列桶中 一个值的散列桶是函数决定的 该函数称为散列函数
	* 访问类型 
		* 支持服务类型 特定的值的记录 值范围的记录
	* 访问时间
		* 查询中使用该数据项或者数据集需要的时间
	* 插入时间
		* 插入新的数据要的时间 更新索引需要的时间
	* 删除时间
	* 空间开销
		* 索引结构占用的额外存储空间 

* 顺序索引
	* 快速访问随机文件中的记录 每个索引结构与特定的索引码包含该索引记录关联起来
	* 被索引的文件可以按照排序组合存储 一个文件可以有多少基于索引码的索引
	* 包含的文件按照索引码顺序排序 索引码对应的索引成为聚集索引 也称为主索引
	* 不同则称为非聚集索引

* 稠密索引和稀疏索引
	* 索引项 或者索引记录 一个搜索码执行该搜索码的值或者多条记录组成
	指向的记录包括磁盘块的表示磁盘块内存记录的块内偏移量

	* 稠密索引
		* 每个索引码值有一个索引项
		* 系统索引码值的其余记录顺序存储在第一条记录之后 为聚集索引
	* 稀疏索引
		* 只为搜索码的某些之建立的索引项
		* 索引是聚集索引才能使用稀疏索引
* 多级索引
	* 在很多元组上建立稠密索引 索引项比数据记录小
	* 大的索引以顺序文件存储在磁盘上 
	* 小的索引可以存放在主存上 搜索一个索引项的时间就会很短
	需要的时候在磁盘取索引块 即使比主机的主存小还是要多次取磁盘块

* 索引的更新
	* 文件记录插入删除的时候更新 索引码对应的更新
	* 插入记录的搜索码值查找 然后索引判断是稠密还是稀疏
	* 输出 查找到删除记录然后 判断索引
* 多码上的索引
	* 一个搜索码可以有多个实现 成为复合索引码 不是单个属性而是一个属性列表
	* 搜索码 按照字典序排序 字母排序基本相同

* B*Tree 树索引文件
	* 在数据插入和删除的的时候保持执行效率的索引结构之一
	* 平衡树结构 树根到树叶的路径长度相同
	* 但是会增加文件的插入和删除处理的开销 空间的开销 存储效率较高的
	是可以接受的

* B*Tree 结构
	* 多级索引 但是结构不同于多就结构索引顺序文件

	*  叶结点
		* 指向索引码值的一条文件记录
	* 非叶结点
		* 形成结点上的多级稀疏索引 并非索引指针是指向该结点的指针
		不过非结点ぞ的指针都是指向树中节点的指针 一个非结点指针最多
		容纳 n个指针 同时至少容纳 n/2个指针 指针稀疏成为结点扇出
* B*Tree 查询
	* 找出索引码值为V的所有记录 执行任务函数find()
	* 如果树存在指定值就从树叶节点触发 重复直达下个叶节点
	首先检查单前的节点找到最小的i让索引码的值k>=v 如果找到
	k=v 抽象p_n指向的结点
	* 叶结点中包含等于V的索引码值 K为一个值 指针指向P的索引码值
	如果不存在为V的记录 find()返回空值

* B*Tree 更新
	* 插入 在函数find()使用查找技术找打索引码值的叶子结点然后插入
	* 删除 找到叶子结点 如果多项含有相同的搜索码值 遍历值找到删除的那项
	* 结点的分裂和结点好合并

* 插入
	* 考虑结点必须分裂一个插入的列子 在instructor关系插入 name值
	为 Adams记录 查找搜索码值需要的空间
	* 分裂结点后将新的结点插入 B*Tree中 以最小搜索码值作为父子结点

* 删除
	* 使用查找算法 定位索引项将结点的索引项删除 结点剩下一个空项了
	二个指针的父节点变成一个指针 没有搜索码值
	* 兄弟结点 同重新分配 指针每个结点有 n/2=2 孩纸指针
	父节点中的值不能正确分开兄弟结点的搜索码 使用顶节点的值来分开兄弟结点
	* 如果上次顶结点 导致了太空的叶子节点可以 和其他的兄弟结点合并 搜搜吗值从副几点
	下移到合并节点

* 不唯一索引码 (一个关系有多个包含同一搜搜码的记录 称为不唯一搜索码)
	* 记录删除效率 会查找很多的项 遍历多个以叶子节点
	* 通过创建包含索引码的其他属性复合搜索码来确保搜索码的唯一
	或者是在有相同搜索码的记录唯一的其他属性 额外的属性也称之为为以后的属性
	删除记录的时候 计算复合搜索码的值 更加有效的删除记录
	* 不唯一的搜搜吗 一个码值在多少条记录中出阿西 树结构就存储多少次
	在空间上更加有效 只存储一次搜索码

= B*Tree 复杂性
	* 插入 删除比较复杂 较少的IO 操作比较费时
	* 如果搜索码没有相同的值 复杂度 log_[2/n](N)
	可以增加属性的唯一 复杂度还是相同的
	* 如果是随机顺序插入 结点仅仅会半满

* B*Tree树的文件组织
	* 索引顺序文件组织缺点就是文件增大的时候性能下降
	存储溢出块中 文件使用索引树解决查找性能下降的我今儿体
	可以作为一个文件组织系统使用
	* B*Tree树的文件组织 树叶的结点存储是记录而不是指向记录的指针
	记录比指针大一个叶子结点的存储记录数目少
	* 组织记录中插入删除 索引项处理方法一样 查找最大码来包含记录的块中
	重新分布其中的记录给新的记录 创建空间
	* 空间利用很重要 占用空间比代码和指针占用空间大很多
	可以改善空间的利用率 对于节点非叶节点可以作用
		* 插入的时候节点满的时候 系统将分布相邻结点给新的项空出空间
		如果相邻的节点已经满 分裂该结点给新 或者分裂相邻的节点
		* 删除记录的时候 结点中的少于 2n/3 系统从相邻的节点介入项 
		如果兄弟结点满足 将所有项分人 剩余的2个结点

* B 树索引文件
	* B tree index B*Tree 相似区别在于B树 去除搜索码值存储的冗余
	在非叶子结点中均出现 每个搜搜吗出现在叶节点中 还在非叶节点重复出现
	* B树中 只允许搜索码的值出现一次是唯一的 更少的树节点来存储索引 
	对应B*树更少的 树节点来存储 出现在非叶子节点的搜索码不会出现在其他的地方
	每个搜搜吗增加一个指针域 附加的指向文件记录对应的桶
	* 进行一次查找访问的节点数取决于搜索码存在的位置 不需要达到叶点就能找到对应的值
	单数存储在叶级的码n倍找到特定的值比B*树来说搜索码快 另外的值要慢
	* 删除更加复杂 被删除的项可能出现在非叶子节点中 包含删除项的子树正确的值来代替

* 闪存
	* 对搜索的描述是存储在磁盘上 内存的结构下降 很多应用的成为代替磁盘存储的竞争者
	* 通过块来组织的 对B树搜影结构在闪存使用 加快存储快的访问速度
	* 不允许物理层的数据更细 在逻辑上实现 每次更新操操作韩城拷贝上的写操作 要求随后清楚 
	块的清楚 降低删除次数的索引结构正在进行 标准的B*树早闪存中使用

* 多码访问
	* 假设隐含的建立在属性的上的索引 来执行关系上的插叙
	对应这个类型的查询 存在多个搜影 建立在多属性的搜索码

* 很多个单码索引
	* 一个码值中有二个索引分别建立在 二个属性中
	如果属性中符合的值很多 必须扫描大量指针 
	一种称为位图索引的解耦在情况下加速集合交的操作者

* 多码索引
	* 可选的策略是复合的搜索码上建立使用的索引
	* 建立搜索码在属性上的顺序索引来回答这个查询对应字母小属性的每个值
	设定那些操作记录 比较条件不是等值条件这个条件不能对应搜索码的一个范围查询
	* 为了加速处理一般复合搜索码的查询 可以使用特殊结构 可以用于这个目的的扩展处理多个
	维上的索引 R树结构为主要的地理数据类型

* 覆盖索引
	* 存储一些属性的值以及记录的指针 存储附加属性对应辅助索引非常有用的
	* 建立在元组关系属性上的非聚集索引 
	* 搜索码上创建索引达到同样的效果 一个覆盖索引减少搜索码的大小非叶节点更大的出 降低索引的高度
---

### 散列的组成形态

* 静态散列
	* 顺序文件缺点是必须分为索引结构来定位属性 必学使用二分法 搜索码上创建索引达到同样的效果
	导致更多的I/O 基于散列 的文件组织能避免访问搜影结构 也提供构造索引的的方法
	* bucket表示能存储一条多条记录的存储单元 一个桶块
	* 为了插入一条搜索码的记录 计算h 给出存放记录buket的地址
	如何相同 检查buket的搜索码值 确定记录是否查找的记录
	* 散列用于不同的目的 
		* 散列文件组织 计算记录的搜索码值上的函数直接包含记录的磁盘块地址
		* 散列索引组织结构 搜索码关联的指针组装成一个散列文件结构

* 散列函数
	* 将所有的搜索码映射到同一个桶中 并不是期望的
	一个记录的时候要检查所有结构的 理想状态是均匀的分布
	* 查找一个需要的记录不得检查所有记录 具有下列特性的分布特性的散列函数
		* 分布是均匀的 散列函数从所有可能的搜索码值集合中分配同样的 
		* 分布是稀疏的 每个桶分配的搜索码值数目几乎相同 散列值びゅ搜索码外部科技配料顺序有关
		* 对数据进行分区 记录分布的数据均匀 每个搜索码对应的一小部分记录
	* 散列函数虽然简单 但是无法提供均匀分布

* 散列索引
	* 散列用于索引结构创建 散列索引键搜索码值以及相应的指针组织成文件结构
	构建出散列索引 作用于搜索码的桶
	* 一个桶对应三个码 映射 每个搜索码值对应一个指针
	一般情况每个码对应多个指针
	* 使用散列索引来表示散列的文件结构 表示辅助散列索引 是一种辅助索引
	从来不作为主要独立的索引结构 杀了文件组织能对记录直接访问

* 动态散列
	* 根据文件大选择散列函数
	* 预计文件大小选择散列函数
	* 文件增大周期性的对于散列进行扩展

---

### 数据结构
> 数据库增加减少 扩展到山里通过桶的分裂来适应数据库大小的变化
可以保持空间的使用率 重组每次对应一个桶 带来的性能开销较低

* 扩充散列
	* 选择具有均匀和随机特性的散列函数 常生的范围比较大
	* 不为每个散列值创建一个桶 只是记录长路文件的时候建通
	* 可扩充散结构
* 查询和更新
	* 要插入搜索码值为K的记录 定位到某个桶 如果有剩余空间
	桶分裂产生的二个桶指针 引入加入散列值的以为 而让桶的地址大小加倍
	原表中的每个表一项都被二个表代替包含一样的指针
	* 如果 I>i 桶的地址多个表指向同 不需要扩大桶的地址分裂桶所有表 的索引前缀
	最左系统 系统分配一个新桶将 I i重制为I加1的在建瓯 桶地址指向原来的表项
	* 插入记录 桶地址波爱护一个指向桶的执行对应结构的一个桶中

* 静态实例与动态散列比较
	* 可扩充散列的优点性能不能随着文章的增长而降低 空间开销是最小的
	尽管桶的地址表带来了额外的开销 表位氮气的每个散列值存放一个指针 因此表较小
	可扩充散列与其他散列比较 空间不能作为将来增长保存桶: 桶的分配的动态的
	* 动态散列形式 --线性散列的参考 可以为溢出更多桶的代价为前提

* 顺序索引与散列的比较
	* 使用索引的顺序组成B*树组织将文件组成顺序文件 可以使用散列来组织文件组成堆文件
	记录不以特定的方式排序
	* 对关系文件组织和索引 考虑问题
		* 索引或者散列组织的周期性重组代价是否可以接受
		* 插入和删除的相对频率如何
		* 最坏实际优化平均访问时间
		* 提出哪些类型的查询

---

### 位图索引
> 为多码上简单查询设计的特殊索引 每个位图索引都是建立在一个吗之上的
> 为了使用位图适应关系 记录必须按照顺序编号 从0开始对给定的n值 记录大小固定文件的联系块
上 该几号可以简单的装成一个块编号和一至多块内记录的记录好
	
* 位图索引结构
	* 位图是位上面的一个简单的数值 最简单的形式中 关系r的属性A上的位图索引
	A能取的每个值建立的位图构成 每个位图都有关系中记录心痛数目的位
	* 什么时候使用位图索引是有利的 
		* 用属性值 来检查的记录读取关系中的所有记录 选择其中的值
		* 实际上位图索引补办加速加快检索的速度 只读取特定性别的记录可能所有块都要被读取到
	* 位图索引对多个码上的选择操作有作用	
		* 执行二个位图的交操作 计算出新的位图
		* 属性可以取2个在建瓯 二个属性取5个值 平均10个记录有满足的条件
		可以找出值为 1 所有位 然后检索相应记录计算查询结果
	* 统计满足给的选择条件的元组数 对于属性分析很重要 计算二个位图的交 然后统计
	位图数目1的 在不需要访问关系的条件下位图索引需要的结果
	* 实际关系大小相比 位图缩影比较小 在位图1个位进代表一个记录
	只是属性中取值多少的 上位图索引就是多少
	* 删除记录在顺序排列记录之间产生间隙 来填充极大的代价识别删除的记录
	可以存储一个存在位图 在给位图中记录替换被删除的记录来完成插入的操作

* 位图操作的高效实现
	* 可以使用for循环 计算二个位图的交来显著较快交操作运算的速度
	位模式指令可以运算32bit 64bit的交
	* 位的交运算可以用于二个条件的与 位图的并可以来计算 二个条件的或
	位图的并的过程和位图与过程相似
	* 补码操作可以计算对条件反取的断言 位图的补码来实现

* 位图和B*树
	* 属性值经常出现的 另外属性值也出现但是频率小的位图可以和B*树所以
	组合来使用 对应在多个记录出现的值 存储一个为题而不是记录的列表
	* 特殊的值在关系记录中出现 为N关系的记录数目 使用64bit的号来标记
	* 常出现的值 B*树节点使用位图来作为压缩的存储机制


* SQL中索引定义
	* SQK标准并未数据库用户提交数据库系统控制操作维护索引的方法
	索引是冗余的数据结构 索引保证正确性来说病史必须的
	* 但是索引对于事务的高效处理非常重要 各项属性 查询 约束
	* 数据库系统可以自动的创建合种索引 但是索引的空间代价和索引对应的更新操作
	选择并不容易 SQL运行通过定语名义对索引的创建好删除进行控制
	* SQL标准不支持物理数据模式的控制 自约束在逻辑数据层
		* create index 创建索引

---


## 查询处理
> 查询处理是指从数据库中提取数据涉及的一系列活动
包括使用 使用高层数据从数据看语言表示的查询语句在物理层上的表达式 为插叙而进行各种转换
以及查询的实际执行

1. 语法分析翻译
2. 优化
3. 执行

* 查询处理
	* 处理之前 系统将查询语句翻译成可用的形式 在扩展的关系代数基础上实现
	* 产生插叙语句的系统内部表示的过程中 语法分析器检查语法 
	系统构造器 该查询语句的语法分析树表示
	翻译阶段使用定义的关系代数表达式 如何执行查询 作为列子
	* 注析 可以申明具体操作的算法 使用多个或一个特定的索引
	加了如何执行的 语句被成为 计算原语
	* 执行一个查询的原语操作被称为插叙执行计划或者查询计算计划
	* 为选择运算指定一个具体的索引称插叙执行引擎
	* 优化查询 查询优惠券必须知道每个操作的代价做出估计

* 查询代价的度量
	* 查询处理的代价可以通过该查询对资源的使用情况 磁盘存取 执行查询CPU时间
	并行分布式数据库心痛中的通信代价
	* 大型数据库中 磁盘存取代价是主要代价 磁盘 存取比内存熟读慢 COP提升び磁盘提升快
	* 磁盘块与磁盘块区分开了 细化磁盘存取代价的估算 写磁盘块的代价是读取的二倍
	算法代价依赖主存中缓存区的大小 最好的清晰是将数据读人到缓冲区 不必要访问磁盘
	最坏就是不能容纳数目不多的数据库 每个关系块 
	* 架设计算机没有其他的活动进行 查询计算计划的响应时(执行时间)作为计划的度量
		1. 当查询开始执行时候 响应时间以来缓存区块ほ的时间
		对于查询进行优化的时候 信息是无法获取的 
		2. 很多磁盘的系统中 响应时间依赖访问如何分布在磁盘上对应磁盘中的数据是很难估计的
	* 优化器常尽量降低查询计划总的消耗资源 而不是尽可能的缩短响应时间
	用于估计的磁盘访问时间的模型  是基于资源消耗查询代价模型实列

* 选择运算
	* 查询处理 文件扫描是存取数据最低级的操作 文件扫描是用于定位检索满足选择记录的搜索算法
	在关系系统中关系保存在单个的专业文件中 使用文件扫描
		1. A1线性检查 
			* 系统扫描每个文件块 对所有记录进行测试 是否满足条件
			做一次磁盘搜索来访问第一个块 文件块的顺序存放的需要更多的磁盘搜索
			* 实现算法的速度慢 但是可用于如何文件 不管该文件的顺序 索引的可用性
			以及选择的种类 
			* 索引结构被成为存取路径 提供了定位和存取数据的一条路径 安装物理顺序存取文件记录的效率较高
			主索引(聚集索引) 运行文件记录安装文件物理顺序一直进行读取不是主索引的出纳称为辅助索引
		2. A2 主索引 码属性的等值比较
			* 具有主索引的码属性的等值比较 使用索引检索来选择使用那个索引的算法有哪几种
		3. A3 主索引 非码值属性等值比较
			* 选择条件基于非码值选择辅助索引 等值条件是吗值可以检查到唯一的记录 时间代价与主索引的情况一样
			* 需要取多条记录文件是按照搜索码进行排序的 索引记录在文件中必然是连续存储的
		4. A4 辅助索引 等值比较
			* 使用等值条件的选择可用使用辅助索引 等值条件是码属性的 可以搜索到唯一一条记录
			索引字段是非码属性 可以搜索到多条记录
			* 每条记录存取在不同的磁盘块中导致每搜索一次I/O操作

* 设计比较选择
	5. A5 主索引比较
		* 在选择条件是比较 可以使用顺序主索引来引导元组的搜索
		在索引中寻找值 满足条件的 首条记录 	对元组进行扫描
		* 对于 < <= 形式没有必要查找索引 只是简单的从头开始进行文件扫描 直接遇上满足的元组为止
		这种形势下索引并没有什么作用
	6. A6 辅助索引 比较
		* 指针取得实际的记录 连续的记录存在不同的磁盘块中 存取一条记录需要一次IO操作
		一次IO 操作需要一次磁盘搜索和块传输 如果搜索记录数很大的时候辅助索引比详细索引还要大

* 复杂选择的实现
	7. A7 利用索引的合取选择
		* 判断是否存在简单条件的属性增加存取路径 如果存在 可以使用A2-A6的算法
		使用迭代达到最小 
	8. A8 使用索引的合取选择
		* 合适的组合索引 选址指定的二个或者多个属性上的等值擦欧洲并在属性字段的组合上存在组合索引
		可以直接使用个缩影 索引的类型决定使用 A2 A3 A4
	9. A9 通过票是否的交实现合取选择
		* 利用记录指针进行记录的标识符 每个条件的字段上有指针的索引 对每个索引继续扫描
		去的那些指定满足条件的知己 运行
		* 扫码各个单独索引代价的总合 加上指针列表交集的记录代价
	10. A10 通过标识符实现析取选择
		* 如有条件上响应的存取路径 组个扫描索引满足单个条件的元组指针 检查索引指针并集 就是满足的
		指定条件所有元组的指针集合


---


### 排序
> SQL查询 对指定的结果进行排序 输入的关系以及排序的时候 关系运算那个得到高效的实现
通过排序码激励索引 然后读取关系 可以完关系的排序

* 外部排序归并算法
	* 不能完全在内存关系成为外排序 最常用的技术就是外部排序归并算法
		1. 建立多个排好的 归并字段 每个归并字段是排序过的包含关系的分几类
		2. 对归并段进行归并 总数N小M 每个归并支墩分配一个块剩下的空寂存放一个结果块
		3. 归并的输出是已经拍下的关系输出我家是缓存减少的磁盘次数 称为N归并
	* 关系比内存大每个归并分一块是不可能的 M-1 归并字段	

* 外部排序归并的代价分析
	* 归并排序的磁盘存取代价 b代关系为记录中的磁盘块数 为每个关系的数据归并消除
	* 磁盘搜索的代价 产生的归并阶段 为读取每个归并段的数据作为磁盘搜索 写回归并磁盘搜索
	读取的数据块


* 连接运算
	* 使用等值连接的词来表示 数据的连接
	
* 嵌套循环连接
	* 计算二个关系r s的连接嵌套 二个循环 r被成为连接的关系的外层
	* 使用的扫码算法相似 不要求有索引 不管连接条件是什么 均可使用 可以作为扩展算法
	* 代价很大 检查二个关系每个对应的元组 二外连接算法所谓代价 元组数目是n*name
	缓存区只能容纳每个关系的数据库 
	* 如果每个关系放在内存中 将这个关系称为内层关系来处理 这样循环只要读取一次


* 块嵌套循环连接
	* 因为缓存区大小而内存不能完全容纳一个观赏的时候 不是以元组方式来处理关系
	可以减少不少块的去屑速度 
	* 嵌套循环连接的一个变种 内存关系每个块与外城关系形成一个元组对
	* 改进版	
		* 如果自然连接等值或者等值连接属性是内层关系的码 对每个外层关系的元组内层循环
		找到了匹配的元组就可以终止
		* 块嵌套循环的连接算法 外城关系不用磁盘作为块单位的 内存容纳大小为打完 流出足够的缓存空间
		给关系 输出结果使用的
		* 内层循环轮流向前 向后扫描 对磁盘存写继续排序 上层扫描的时间在缓存区使用
		* 内层循环上有索引 有效的结合索引查找大文件扫描方法

* 索引嵌套循环
	* 对于外层关系r的每个元组在关系s上索引继续操作 检索相关的元组
	最坏的情况 缓存区只能容纳关系r的一个块和索引的一块 读取关系r b 需要 IO操作
	* 对于关系r中的每个元组在s上继续索引查找 连接的代价使用b来计算

* 归并连接
	* 排序--归并--连接算法 计算既然连接的等值连接 r(R) s(S)执行的自然连接元素的关系 R∩S 表示二个公共的属性

* 归并算法
	* 系统属性的二个元组的拼接 投影除去投影的重复属性 归并连接算法为每个指针分配一个
	指针 这个指针相应关系的第一个元组 随着关系的算法继续 病例关系 元组集合能别装入主存
	* 使用关系具体走一遍归并连接算法是很有启发性的
	* 归并联机算法要求主内存 在连接属性上有相同属性的元组集合 既关系 
	可以使用系统连接属性值的元组回家采取块嵌套循环连接
	* 如果任意输入关系 未排序 先使用归并连接算法 扩展到等值的连接

* 散列连接
	* 实现自然连接和等值连接 在散列连接算法使用函数来划分关系元组
	成连接属性上具有相同散列的元组集合

* 基本思想	
	* 如果关系r的元组 与其他关系的元组满足连接条件 在连接属性上就具有相同的值 
	将该值散列函数映射到关系r的那个元组 必在r1的元组关系中 
	* 散列连接算法对各部分划分的时候对单独的索引嵌套循环了解 该算法先构造散列或者索引
	然后使用对元组使用探查
	* 散列索引是在内存中建立的的不要访问磁盘来检查元组 搞砸索引的山里函数与前面使用的散列函数的不同的
	还是要对 连接的属性进行散列映射 索引嵌套循环连接的时候使用探查输入检查
	

* 递归划分
	* n的值大于等于内存块 没有足够的缓存块 关系的划分不能一遍完成 完成关系的划分需要很多趟 
	输入的最大分数 不超过输入的缓存快速 
	* 每次划分的使用的散列函数与上次散列函数的不同 不断重复的划分成为递归划分

* 溢出处理
	* s的散列索引大于主存 构造输入关系的划分 发生散列溢出 如果构造输入关系
	在连接属性上具有相同值 
	* 所选的散列函数不符合随机性 均匀性 则会发散列溢出 划分元组多余平均数
	另外划分的元组数比平均数少 这种划分成为偏斜的
	* 溢出分解算法不同的 溢出避免法 保证构造阶段不会有溢出发生 溢出避免法构造输入关系划分多个小划分
	然后将划分组合 保证每个组合划分能别内存容纳 


* 其他运算
	* 去除重复
		* 排序的方法去除重复 排序的时候元组相互邻近 桑楚副本留一个元组副本即可
		 创建归并段时候发现重复元组 在归并段写回磁盘去除重复 减少重复的元组
		* 将递归段写回磁盘上 去除的关系排序的代价估计一样
		* 使用散列来去除重复 
			* 基于元组 散列函数对关系划分 
			* 划分关系读入内存 建立内存索引 
	* 投影
		* 对于每个元组进行投影 得到结果关系重复的记录 去除重复记录
		* 投影属性关有关系吗 结果中不会有重复元组
	* 集合运算
		* 实现 并 交差 对关系排序 然后扫描 相同的时候保存一个关系元组
		* 二个输入关系扫描一次按照排序 最坏关系只有一个缓存块 减少磁盘次数

---


## 查询优化
> 复杂查询 有很多策略 查询优化就是从策略照吃执行的处理过程
查询执行代价最小的查询执行计划
关系代数级别的发生 找出表达等价但是执行高效的表达式

* 概述
	* 一个表达式常生很大的中间关系 我们只关系关系的少数元组感兴趣
	只对应关系中的10个属性有用 减少访问的关系元组极少中间结果大小
	* 执行计划定义每个运算使用的算法 以及关系如何协调 
	* 给定关系表达式 查询优化的任务是产生执行计划 

* 执行计划
	* 一个执行计划定理每个运算的使用算法 以及运算之间如何协调 每个运算有不同的算法
	从而常生其他可执行的关系
	* 给定一个关系代数表达式 长训优惠券产生一个查询集合 得到的结果集执行代缴最小
		* 逻辑上给定表达式等价的表达式
		* 产生的表达式不同方式注解
		* 估计每个执行集合的代价 选择最小的
	* 查询优化器 1-3 交叉的常生表达式并注解 执行计划产生代价通过关系的统计信息表达

* 关系表达式转换
> 一个查询表达多种不同的形式没在形式 有不同的执行代价
考虑其他的可选等价表达式
二个关系表达式在有效数据库实列产生系统的元组集合成为是 等价的

* 基本关系代数
	* SQL语言 输入输出都是元组的集合 
	* 关系代数多重集合版本评估SQL查询 
	* 有效的数据库 二个表达产生基于关系代数的

* 查看执行计划
	* 为计划估计代价随着集合显示 
	* 代价没有意外的意义
	* 第一个输出估计代价 第二个表示 有用输出的代价

* 等价规则
	* 不同表达式是等价的 第二种形式的表达式代替第一种 反之亦然
	1. 合取选择运算 分解为选择运算的系列称交互的级联
	2. 选择运算满足交换律
	3. 投影运算只有最后一个是必须的
	4. 选择操作可以与笛卡尔乘结合
	5. 连接运算满足结合律

* 连接的次序
	* 运算次序对于减少结果大小是很重要的 大部分优化器在连接次序做优化
	* 执行查询考虑其他的因素 不关系属性连接的次序 显示更改顺序的任意的 满足自然交换律
	* 笛卡尔积产生较大的临时关系 可以使用交换律装成有效的表达式

* 表达式的枚举
	* 如果在子表达式 使用等价的规则交表达式 二个表达式指向子表达式减少空间的需求
	* 不变总是等价规则产生的表达式 可以减少优化的时间

* 表达式结果统计大小的估计
	* 操作的代价依赖输入大小的统计 给定表达式估计连接代价
	* 列出存储数据库中目录的统计信息 估计不同结果的统计信息

* 目录信息
	* n 关系r的元组
	*b 包含关系r元组磁盘块数
	* i 关系r中元组的字节数
	* f 关系r的块因子
	* v 关系r中属性A出现的非重复个数


* 索引的统计信息
	* B 树高度索引中叶节点的页数保存在目录
	* 每次关系修改同时更新 统计信息 许多心痛不表示每次修改统计信息
	是系统信息 导致信息不完全精确
	* 形式优惠券维护更深的统计信息提高执行代缴的估计及强度 


* 物化视图
	* 定义视图数据库只存取定义该属兔的查询语句 物化视图是内容计算并存储的视图 
	带来冗余数据 读取物化属性内比之下定义视图的查询代价低得多

* 视图维护
	* 能在视图定义使用的数据变化的时候保持更新 称为视图维护
	* 选择视图定义的每个关系插入定义触发器 更具触发器对物化视图的重新计算
	* 增量视图维护
	* 多次数据库执行立即视图维护 部分提供延迟视图维护

* 增量视图维护
	* 一个物化视图过时的关系改变 更新元组的操作替换作为删除该元组
	一个关系或者表达式改变成为他的差异
	* 连接操作
		* 物化的视图的连接关系 r作为插入的元组集 为了更新物化视图将元组插入改变
	* 选择和投影操作
		* 投影物化视图 建立关系在模式的基础上包含二个元组
		* 关系删除一个元组集合的时候对每个元组做操作
			*  t表示在属性上的投影 在物化视图找到对应的计算域
			* 然后对存储的计算减一 计算变为零则删除
			* 处理插入 对每个元组做出擦做 
				* 如果视图存在 对存储计数加1 
				* 没有将 属性键入物化视图中去

* 聚集操作
	* count
		* 按照属性分组 然后对属性进行技术
		* 元组插入到关系的时候对应每个元组 对应的操作在物化视图中查找
		关系 对每个元组 物化视图中 对该计数加1
		* 关系删除一个元组的时候 对每个元组 找出属性 如何对计数减少1
		*  如果变为0 删除
	* sum
		* 元组集插入关系 对每个元组操作
			* 物化视图中找属性 如果找不到将属性加入物化视图 在投影处理类型
			* 关系r中删除元组 对每个元组 找到属性然后将聚集值减去 然后计数减1
	* avg 
		*  插入删除的时候在关系物化视图的平均值的不可能的 依赖原值的插入 删除元组还与依赖组数
		*  维护 count sum 计算出来的平均值
	* min max	
		* 对关系插入操作的处理的直接的 对关系上的删除对维护找到对应的值


* 查询优化和物化视图
	* 重写查询利用的物化视图
		* 有物化视图的使用 用户提交了查询 智久优化的用户提交查询相对
		更加有效的查询计划 查询计划的工作包括知道物化视图的处理有效性
	* 有物化视图的地方替换其他定义
		* 物化视图可用但 没有索引 用户提交了一个索引的关系有 
		查询优化最后就是替换执行 全篇扫描

* 物化视图和索引选择
	* 物化那些视图的最佳法案 视图集的选择必须基于系统的工作负载
	反映是负载系类的关系操作 选物化视图能使用系统完成查询更新的工作 负载耗费的更新操作
	* 索引 是延伸的数据能提高查询速度 减慢更新速度 索引选择问题简单 物化的视图的选择无关


* 高级查询优化
	* top-K
		* 查询需要返回的属性上排序的结构 对弈特定的值只去取K个
		返回的值的特定的 支持limt K 子句 导致结果之返回前K个结果 数据库支持方式运行
		* K值小的时候查询优化先产生结果集 然后排序效率会很低
		使用游戏结果的流水新查询集合 在top-K查询 排序属性的最大值是多少

* 连接最小化
	* 查询视图的产生实连接的关系计算比查询进行的连接关系更大
	* 物化视图包含 元组的连接 使用涉及属性 在上下连接没有产生元组的额外拷贝

* 更新的优化
	* set where 子句涉及子查询在更新优化的时候考虑在内 涉及选择操作扫描的更新
	* 一个个性元组在扫描的时候超重复索引二次 同一个元组有相似的结果
	* 更新的操作者英雄执行的问题 
		* 定义更新 查询受到影响元组的列表 更新元组和索引 然后风增加执行计划


---

## 事务
> 数据库中的操作集合被认为一个独立的单元 构成单一逻辑工作单一的操作集合被称为事务
要么执行整个书屋要么提供不执行 避免不一致的事务并发执行

* 事务的概念
	* 事务是访问数据项的访问单元 高级操作语言 或者变成语言访问数据库的执行引起来
	形如 begin transection end transection 语句来界定
	* 聚合操作必为单一的 不可分割单元出现 事务不可分割的
	无论事务是否失败 要求成立存在事务的主存 称为原子性
	* 事务单一单元操作是不属于事务的数据库操作分开的 每个事务多个SQL语句组成
	保证事务的执行不被干扰 称为 隔离性
	* 保证太过复制而不使用SQL构造数据为准依赖程序的约束 称为 一致性

* 数据库系统维护事务的性质(ACID特性)
	* 原子性
		* 事务的操作是数据库的正确反映过来
	* 一致性 
		* 隔离执行事务保证数据库的一致性
	* 隔离性
		* 多个事务并发执行 系统保证对事务 独立执行
	* 持久性
		* 一个事务成功完成 对数据库改变是持久的

* 存储结构
	* 易失存储器
		* 在系统崩溃不会保存:主存储器和高数缓存器 
		* 访问非常快 内存访问的熟读贝莱
	* 非易失存储器
		* 系统崩溃可以保存 存储的二级设备: 磁盘闪存
		* 读取熟读特别慢 对于随机访问二级设备容易故障 信息丢失
	* 稳定存储器
		* 稳定存储器永远不会丢失 理论上不可能

	* 为了事务的持久修改写入稳定的存储器 为了事务的原子性 日志记录需要稳定写入
	保证持久性原子性曲剧稳定存储器实现有多稳定 

* 事务原子性和持久性
	* 事务并非成功执行 这种事务称为中止 保存原子性对数据库的状态不影响
	* 中止事务对数据库做过的改变必须陈晓 一旦被撤销事务已经回滚 
	恢复机制复制管理事务中止 
	* 维护日志提供重新修改保证原子性和持久性的可能 成功完成的执行已经提交
	对数据更新已经提交事务继续一致状态 出现系统故障也要保持	
	* 一旦事务提交 撤销提交的事务影响唯一的方法就是补偿业务

* 事务的状态
	* 活动的 事务执行处于这个状态
	* 部分提交的  最后一条语句执行后
	* 失散的  正常执行不能继续后
	* 中止的 事务回滚并且回复事务执行的状态后
	* 提交的 事务提交之后
* 事务进行中止状态 然后是提交或者中止的成为已经结束的
事务从季活动开始 完成最后的语句就进入最后的提交状态 事务完成执行
实际输出依然存在主存中 硬件故障事务不得不中止

* 事务中止状态的选择
	* 重启事务 事务中止是硬件错误而不是事务的内部逻辑产生
	* 杀死事务 事务的内部逻辑错误 重写程序才能更改

* 事务的隔离性
	* 事务处理允许多个并发执行 导致数据一致的负载问题 
	我们强制事务串行的执行 
	* 提高吞吐量 资源利用
		* 一个事务多个步骤组成 IO活的 CPU磁盘 并行 增加吞吐量
		给定执行的事务增加 处理器磁盘的利用率提高
	* 减少等待时间
		* 事务处理各种事务时间不同 并发执行 共享CPU周期磁盘的存取
		减少执行事务的不可预测远程 减少平均响应时间
	* 数据库使用并发执行的东京与操作系统使用的多道程序的动机是一直的
	* 如果并发控制操作系统辅助多个调度的可能的 处于一直的挑拨保证执行的调度处于一致的状态
	数据库系统完成任务是	并发控制部件
	* 并发执行中保证仍会修改没有并发的一样保证数据库的一致性 这种调度成为可串行化调度

* 可串行化
	* 确定调度是可串行化的 串行调度是可以串行化之前考虑如何确定的
	如果多个事务的步骤的交错执行 调度是可串行化的 
	有用事务就是诚信 确定事务有那些操作多个操作是有困难的 不会考虑事务对数据的可执行的
	各种不同操作 只考虑 read write 

* 冲突可串行化
	* 考虑一个调调S 有属于I 与J的二条指令 如果引用不同数据项Q 
	二者的属性是重要的只粗粒read write 指令考虑四个情况
		1. I = read(Q) J = read(Q) 次序无关 读取的Q值相同的
		2. I = read(Q) J = write(Q) I先J T不会读取T1 T1写入Q
		3. I = write(Q) J = read(Q) 次序同样重要上条一样
		4. I = write(Q) J = write(Q) 顺序无关 调度S下一条read写入
	* I and J 不同事物在系统数据项上操作只有一个write的时候 I j 是冲突的

* 非冲突的指令
	* 交换T的 read B T read A 的指令
	* 交换T的 write B T write A 的指令
	* 交换T的 write B T read A 的指令
* 得到一个串行调度 执行显示reda write指令产生相同状态 
如果调度S 可以得到S^ 称为冲突等价

* 确定冲突可串行化 设定S是一个调度 构造一个有向图 称为优先图
	* T执行read Q之前 Ti执行write Q
	* T执行write Q之前 Ti执行read Q
	* T执行write Q之前 Ti执行write Q

* 串行化执行顺序  拓扑排序
	* 用于计算优先图相一直的线性顺序 可以来说可以得到多个顺序
	* 判定冲突的可串行化 需要改造图并环测运算得到顶点事务
	* 存在二个调度 产生相同的结果不是冲突等价的 
	* 存在冲突等奖定义限制比调度定义轻松一些 对于系统来说结果相同而不是分析操作
	属性角度递增和递减是一样的 事务可能表示一条复制的SQL语句

---

### 事务隔离性 和原子性
> 如果事务失效了 撤销事务保持原子性 有原子性的要求依赖事务 对系统的调度类型做出限制

* 可恢复调度
	* 事务只执行一条指令 成为部分调度 执行之后立即提交
	但是已经提交不能中止 表现了事务发生故障不能恢复
	* 可恢复的调度应该满足 每个事务T 读取之前所写的程序项
	T先Ti提交 如果是可以恢复的应该延迟提交

* 无极联调度
	* 调度可以恢复从 事务Ti的故障中正确恢复需要回滚诺干事务 其他事务写的数据项发生这种情形
	某个事务依赖另一个事务 前面的事务必须回滚
	* 单个事务故障导致其他事务回滚称为联级回滚
	* 回滚到底撤销大量工作 是不希望发生的 需要限制练级回滚 
	* 无极联调度 满足对事务的度读写数据提交容易验证是可恢复的调度

*	事务的隔离性级别
	* 可串行 允许程序忽略并发性的关系 独立执行的时候保持数据的一致性 使用串选行来保持
	* 可串行化
		* 保证串行调度 
	* 可重复读取
		* 允许数据提交的数据在一个事务读取二个数据期间 其他事务不更新该数据
		不要求其他事务的可串行化
	* 已提交的读
		* 允许读取提交数据 但是不可以重复的读取 事务二次读取一个数据期间 
		另外事务更新数据并更新数据的提交
	* 未提交的读
		* 允许读取为提交的数据 最低一致性的级别
	* 默认的隔离性质是 已提交的读 可以申请其他的隔离性

* 隔离性级别的实现
	* 并发控制机制来保证 多个事务并发执行的时候 不管操作系统的共享资源来标准只产生生调度
	* 并发空寂机制的目的为了提高并发控制的机制

* 锁
	* 一个事务封锁访问的数据项 而不是封锁这个数据库 
	* 事务必须在足够长的世界保持可串行化 
	* 其他事务上没有任何锁一个事务保持数据项上保持的排他锁

* 锁的时间戳
	* 保证每个事务分配一个 开始的数据项 维护的时间二个时间戳

* 多版本快照隔离
	* 事务运行读取旧版本的数据而不是另一个提交串行化写入新版本的数据项
	* 每个事务开始具有自己的版本快照私有版本读取数据的时候将事务隔离开


---

## 并发控制
> 数据多个事务并执行 事务的隔离性不能宝座 为了保持事务 通过并发控制机制来实现并发事务的管理

### 基于锁的协议
> 保持事务管理的方法就是对数据相互的方式进行访问 运行事务访问该事务有锁的数据项

* 锁
	* 共享锁 
		* 如果事务 获得了数据项的共享锁 
	* 排他锁
		* 事务活动数据项的排他锁
* 对数据项进行申请适当的锁 事务只在并发控制管理器授予所需要锁才能继续其他操作者
可以使用多个事务读取一个数据项但限制一个事务进行写操作
* 对于给定锁的类型集合 可以定义一个相容函数
	* A与B代表任意的锁 数据项Q存在B类锁 事务T立即获得数据项Q的锁
	称为A类型锁与B类型锁的相容的 可以托管矩阵方便表示
	* A与B代表任意的锁 事务T请求对数据项Q加A类锁 事务T在单前数据Q上有B锁的类型
	* 共享型与共享型相容的 排他类型不想撸 在一个具体数据项可以同时有
	* 要访问一个数据 T必定给该数据项加锁 一个被另一个事务上加了不相容类型的锁
	在事务特有不相容锁释放之前 并发控制器不会授予所 T只好等待 直到奇台起诉持有不相容类型锁的释放
	* 如果使用封锁对数据读写立即解锁 可能进入不一致的情况 对申请的数据项加锁不对氮气的数据项解锁会发生死锁
	避免不一致使用封锁 死锁是必然产生的 用过回滚事务解决 但是 不一致会引起系统中的问题 数据库系统是不能处理的
	* 系统每个事务遵循锁的协议 一组规则 对事务何时对数据进行加锁 保证解锁 封锁协议性质可能的调度数目 调度组成的集合是
	可能可串行化的调度的真子集 运行串行化调度保证隔离性

* 锁的授予
	* 事务申请对数据项加一类型锁 没有其他书屋在数据项加了冲突的锁 则可以摄于锁
	小心防止以下情形
		* 事务在数据项只有共享锁 另一个事务加了排他锁 等待释放共享锁
		* 有新的事务申请对该数据加共享锁 每个事务在授权加锁一个小时释放锁 可能存在事务序列每个事务申请对数据项加共享锁
		在一个小时内释放锁 总是不能在数据项加排他锁成为饿死starved
	* 避免锁饿死
		* 事务T申请对数据Q加M锁的 并发控制狗安利下授权加锁的条件是
			* 不存在数据项Q上持有的M锁冲突的其他事务
			* 不存在等待对数据项Q加锁而且于T申请加锁的事务
			一个加锁请求不会被后加锁申请阻塞

* 二阶段封锁协议
	* 保证串行可行性的协议是二阶段封锁协议 每个事务分二个阶段提出加锁和解锁的申请
		1. 增长阶段 事务可以获得锁但不能释放锁
		2. 缩减阶段 事务可以释放锁 但不能获得新锁
	* 最初事务处于增长阶段 关机需要获得锁 一旦事务获得锁 该事务释放锁  金融缩减阶段不能发出加锁的请求
	* 解锁并不必非得出现事务没 可以子啊事务之后 保存二阶段锁的特性
	协议保证可串行化 对于事务调度该事务获得加锁的位置 成为事务的封锁点
	多个事务根据封锁点几下排序 这个顺序就是事务的可串行化顺序
	* 二阶段封锁协议不保证不会死锁  

* 严格二阶段封锁协议
	* 避免联级回滚
	* 要求封锁是二阶段意外 要求事务所有的排他锁补习在事务的提交才可以释放
	保证为提交事务在写的数据提交之前以天派方式加锁 防止其他事务读取


* 强二阶段封锁体系
	* 要求事务提交不能释放任何锁 在二阶段封锁条件下事务安装提交的顺序串行化
	* 对基本的二阶段体系的修改 运行锁转换 提供共享锁升级为排他锁 表示共享到哦爱他的转换
	用降级表示排他到共享的转换 锁转换不能随意进行 锁升级只能发生在增长阶段 降级只能在缩减阶段

* 广泛使用的机制 基于事务的读写请求自动为和使用产生适当的加锁解锁指令
	* 当事务T进行readQ 操作时 系统产生lock-S 指令 readQ跟追其后 
	* 当事务T进行writeQ 操作时 系统检查T是否在Q上持有共享锁
	* 事务提交中止后 该事务持有的锁被释放

* 锁的实现
	* 锁管理器实现作为一个过程 从事务接收消息并反馈消息
	针对请求返回授予消息 或者请求事务的回归消息（发生死锁的时候）解锁消息知悉要一个确认的回答
	* 使用的数据结构
		* 管理器为目前已经加锁的每个数据项维护一个链表每个请求为链表的一条记录
		达到请求的排列顺序使用数据项名称为索引的散列来查找链表中的数据项
		这个叫做 锁表(lock table)
		* 一个数据项的链表每条记录由那个事务提出请求 以及请求什么类型的锁 该记录表示请求算法授予锁
	* 锁管理处理请求方式
		* 一条锁请求消息达到时候 响应数据项的链表存在在没增加记录否则
		新家仅包含请求记录的链表 没有加锁的数据项授予第一次加锁请求 事务已经加锁的数据申请加锁搜狐
		该请求与单前持有的锁相容 并且请求授予锁的条件 锁管理器为该所请求授予锁 否则该请求只有等待
		* 管理器受到事务的解锁消息 该事务对应的数据项链表中的记录删除
		然后检查随后的记录 如果有请求是否授权
		* 如果事务中止 锁管理器删除该数据正在等待锁的请求 数据库采用实弹撤销该事务
		该中止事务持有的锁被释放

* 基于图的协议
	* 非二阶段协议 需要每个事务如何存取数据库的附加信息 最简单的模型需求我们知道访问数据项的附加信息
	每种信息的大小不同 模型要求访问数据项的顺序 已知的信息构造非二阶段封锁协议 保证冲突的可执行
	* 为了获取事先的知识 要求数据集合D=[d1 d2 d3] 满足偏序 任何访问的事务必须
	* 集合D可以被视为有向有向无环图 称为 数据库图 只关心带根树的图成为树形协议的简单协议
	只使用排他锁 负载基于图的封锁协议

* 树形协议 
	* 使用加锁指令 lock-x 每个事务对一个数据项多加一次锁 并遵从下列规则
		* T首次加锁对任何数据项进行
		* T对于数据项Q加锁的前提是T持有持有Q的锁
		* 对数据项解锁可以随时进行
		* 数据项T加锁并解锁ほ T不对数据项加锁
	* 所有树形协议的冲突可串行化

* 提交依赖
	* 事务执行对为提交数据项的读操作 就数据项执行写操作的事务记录提交依赖
	事务提交依赖完成之前 事务不得提交 如果任何一个事务中止 依赖的也必须中止
	* 树形谢雨不会产生死锁 所以不需要设置回滚 
	* 较早的时候释放锁 减少了等待时间 增加了并发性
	* 事务可能更不访问数据项加锁 这种额外的封锁导致等待时间的加多 事务必定给树梗加锁
	降低并发性
	* 对于事务集 存在不能通过封锁协议得到的串行协议

* 死锁的处理
 	* 如果存在事务集 该集合每个事务在等待另一个事务系统处于死锁状态
 	存在事务等待集合 使事务等待别锁住的事务 等待锁住的数据项没有一个事务能别进展
 	* 对于陷入死锁的事务 部分回滚 在该点得到一个锁 释放该事务解决死锁
 	二种主要的方法解决死锁 
 		* 使用死锁防御来保证系统永不进入死锁状态 
 		* 另一种方法是运行系统进入死锁让后使用死锁检测和死锁恢复的机制进行恢复 二种方法均引起食物的回滚 

* 死锁的预防
	* 一种是通过对加锁进行排序或者请求同时获得所有的锁保证不会发生循环等待
	* 接近死锁恢复 等待可能导致死锁进行事务回滚而不是事务等待加锁
	* 存在二个主要的缺点
		* 事务开始通常得到预测数据项西需要的锁
		* 数据项使用的可能低 数据项可能封锁很长时间而用不到
	* 另一种机制是对数据项加一个次序 同时事务只能按次序满足顺序的封锁数据项
	在树形协议讲的机制 采用偏序数据项
		* 方法的变种是采用二阶段封锁关联的全序一个事务锁住了特定的数据项不能申请顺序中位于数据项前面的数据项上的锁
		只要在事务执行前 访问的数据项的已知的该机制容易实现 如果实现二阶段封锁潜在的并发控制不用更改 保证锁申请的正确顺序
	 * 抢占事务回滚 
		* 如果事务Ti申请的锁以及被事务T持有 申请Ti的锁通过回滚事务Ti被抢占 并授予Ti 为控制抢占
		给每个事务赋予一个唯一的时间戳 决定事务氮气等待还是回滚 并发机制使用封锁机制
		1. wait-die 机制基于非抢占技术 事务Ti申请数据项被Y持有 仅当Ti的时间戳小T 允许T等待反正回滚(死亡)
		2. wonnd-wait机制基于抢占技术 事务Ti申请数据项被Ti持有  Ti的时间戳大于T 允许Ti等待 否则Ti回滚
* 锁超时 lock timeout 
	* 申请锁的事务多等待一个段给定的时间 在此段时间为授予该事务的锁称该事务操作 该事务自己回滚并重启
	如果存在死锁 卷入死锁的检查以及恢复之间
	* 超时机制实现容易 如果事务短并且长时间等待可能由死锁引起 该机制运行良好然而一般很难圈定事务超时等待多长时间
	如果已经发生死锁等待时间太长导致不必要的延迟 等待时间太短 引起事务的回滚造成资源的浪费 可能会产生饿死

* 死锁检测与恢复
	* 发生死锁系统必须从死锁中恢复 
		* 维护当前数据项分配给事物的有关信息 以及任何为解决的数据项请求信息
		* 提供使用信息判读实体进入死锁状态的算法
		* 检测算数判定存在死锁从 死锁恢复

* 死锁的检测
	* 等待图的有向图来描述 G=(V E) 对组组成 其中V是顶点E是边集 顶点事务由该事务的所有事务组成
	边集E的每个元组是一个有序对Ti->Tj 如果属于E存在从事务T到Ti的有向边 该是在等待释放是数据项
	* 仅存在等待的图包含环的时候系统存在死锁 该环的每个事务存在死锁的状态监测死锁不持有事务的数据项才从等待图删除
	并周期性的激活等待图中搜索环的算法 

* 从死锁中恢复
> 检测算法存在死锁的时候系统必须从死锁中恢复 解除死锁常用的方法是回滚一个或者多个事务
	1. 选择性牺牲者 给定处于死锁状态的事务集 为解除死锁 决定回滚那个事务可以打破死锁
	应该让事务回滚带来的代价最小 但是很多因素影响事务的回滚代价
		* 事务计算了多久并在指定完成任务前计算多长时间
		* 该事务使用了多少数据项
		* 完成使用需要多少数据项
		* 回滚牵涉多少事务
	2. 回滚 一旦决定回滚那个事务并行决定该事务回滚多远
		* 最简单的方法就是 彻底回滚 中止该事务然后重新开始
		事务只回到可以解除的死锁处会更有效 
		* 这种部分回滚要求系统维护正在运行的事务额外的信息状态 记录锁的申请序列的事务执行更新
		死锁检测应当确定 需要释放那些锁
	3. 饿死	
		* 如果选择牺牲高宇代价因素可能同一事务被选为牺牲者 该事务总是不能完成指定的任务
		这样就发生二手 必须保证一个事务别选择牺牲者的次数有限 最常用的方案就是在代价隐私保护的回滚次数

* 多粒度
	* 将一个数据项作为同步执行的单元 某种情况下多个数据项聚集为一组作为一个同步单元
	这样使用的是一种封锁协议 事务必须给数据库中每个数据项加锁 哼校服时间 的如果不给数据库加锁
	并发性就丧失
	* 允许系统定义多粒度的机制运行  各种大小的数据并定义数据颗粒的层次结构
	小的颗粒数据项嵌套在大颗粒的数据项中实现 中止层次结构可以图形化表现为树 
	多颗粒树的非结点表示好歹相联系的数据在树协议每个节点是相互地理的数据项
	* 树中每个节点都可以单独的加锁 在二阶段体系封锁协议中 使用共享锁和排他锁
	当事务对一个节加锁成为子节点每个区域作为节点的文件组成 每个区域file类型节点作为子节点
	文件record类型的节点组成文件作为子节点的记录组成 不能同时属于多个文件
	* 系统如何判定节点是否加锁
		* 搜索整颗树 方法破坏了多粒度分数机制 获得更有效的方法是引入新的锁类型 重向锁类型
		如果节点加上了意向锁 在叫低层进行显然加锁 
		* 共享锁关联是意向锁 排他锁管理的另一种意向锁 如果节点加上了共享型意向锁在树较低进行显示
		封锁 但是只能加共享锁 
		* 如果一个节点加排他型意向锁 在该树较低层进行显示封锁可以加排他锁成共享锁

* 多层封锁协议
	* 保证可串行每个事物要求对数据项加锁
		* 事物不许遵循锁类型的相容函数
		* 必须事先封锁树的根据点 并且加任意类型的锁
		* 对数据项的父节点有锁的时候可以加

---

### 基于时间戳的协议
> 对冲突事物的次序是在执行的时候进行申请的 记录时间戳为二者申请的 类型不相容是一个锁决定的
事物可串行化方法的实先选定事物的次序最常用的方法是数据排序的机制

* 事务的时间戳
	* 对系统每个事务 唯一固定的时间戳联系其 执行数据库赋予的 事务赋予时间戳新的事务进入系统
	* 使用系统时间的值作为时间戳 事务的时间等于该事务进入系统的时钟值
	* 逻辑计数器 赋予一个时间戳计算机增加一个技术 事务的时间戳等于该事务进入系统的计数值

* 实现这个机制每个数据项需要二个时间戳之关联
	* W-timestamp 表示知晓writeQ事务的最大时间戳
	* R-timestamp 表示知晓readQ所有是的最大时间戳
	* 新的read Q或WriteQ 知晓的时候 这些时间戳更新

* 时间排序协议
	* 保证任何有冲突的read write操作按照时间顺序知晓 
		1. 假设事务T发出readQ 
			* TS（T1）< -W-timestamp(Q) 读入值被覆盖 read操作拒绝T回滚
			* TS（T1）> -W-timestamp(Q) 进行read操作 write操作拒绝被回滚
		2. 假设事务T发出write(Q)
			* TS（T1）< -R-timestamp(Q) 读入值是需要的  write操作被拒绝 T回滚
			* TS（T1）> -W-timestamp(Q) 进行read操作 write操作拒绝被回滚 T回滚
	* 系统执行write操作 将W-timestamp 设置为TS
	* 保证冲突的串行化 被时间戳顺序执行
	* 保证无死锁 不存在等待事务 但是冲突短事务引发的长事务反复抽取导致长事务饿死的现象
	* 产生不可恢复调度 该协议能进行扩展 保证调度可以恢复
		* 事务末尾执行写操作保证可恢复性 无级限联 在写操纵的时候事务不许写完任何数据项
		* 可恢复性 无极联性受限的封锁形式来保证 对为提交的读写可以推迟到事务提交之后
		* 可恢复性 通过耕作为提交写操作来单独的保证 事务读取其他事务写的数据 只有在其事务提交以后

* 基于有效性检查的协议
> 要求每个事务在生命周期完成三个阶段的执行 取决于该事务是只读事务还是 更新事务
	1. 读阶段 系统执行事务T各项数据被读取并保存在事务T的局部变量中 所有write操作是对局部临时变量操作不对数据库真正的更新
	2. 有效性检查阶段 判定事务可以执行write操作而不违法可串行 如果事务有效性检查失败 终止这个事务
	3. 写阶段 事务通检查 保证然后写操作进行临时局部变量被复制到实际中 只读忽略这个阶段

* 有效性检查阶段
	* Start(T) 事务T开始执行的时间
	* Valldation(T)  事务T完成阶段开始的有效检查时间
	* Finish(T) 事务T完成写阶段的时间
	* 自动防止联级回滚 只有发出写操作的事务提交后实际的写才发生
	在长是饿死的可能 冲突导致短事务反复重启 之前冲突的事务暂时阻塞
	* 事务的乐观执行 能够完成执行并有效 也称为乐观的并发控制 封锁的时间戳排序的悲观的
	检查到一个冲突时候钱婆事务等待或者回滚 调度有可能是冲突的可串行化的

* 快照隔离
	* 特殊的并发机制 在事务执行的时候给数据库一份快照然后事务在该快照上操作和其他并发事务
	完全隔开 
	* 快照中的数据值包括自己写以及提交的事务隔离对只读事务是理想的 不用等待 其他的事务完全个快
	不会被并发管理器中止 更新的数据库事务将更新写入数据库之前 处理其他并发更新存在的冲突
	* 更新操作发生在事务的私有工作空间中 知道事务提交 写的操作必须Wie一个院子操作执行

* 更新事务的有效性检查
	* 决定是否共享事务的提交 二个并发执行的事务会向同一个数据项 
	但是操作各有私有快照隔离 任何事务看不到对方事务做的更新 
	* 第一个写入的将被第二个覆盖 导致更新丢失 必须避免
	* 快照隔离的变种 防止更新丢失 
		* 先提交获胜
		* 先更新者获胜
* 先提交获胜
	* 检查是否有T并发执行的事务 对T希尔的数据项已经将更新写入数据库
	* 如果发生这种事务 T中止
	* 如果没有发生 T提价 并更新写入数据库

* 更新者获胜
	* 数据项被并发事务更新 T中止
	* T能执行操作包括提交 当事务提交或者中止时 锁被释放

* 串行化问题
	* 快照隔离开销低并没有中止发生除非二个并发事务更新同一个数据项
	快照隔离里边不保证可串行化
		* 假设二个事务T 和T1 以及数据项A B T读取A B然后共享B T1读取A B然后更新A
		没有其他并发事务 T T1并发的因此任何事务在快照内是看不见对方更新 都可以提交
		* 一对事务每个读对方写的数据但存在二个同时写的数据 这个时候称为写偏斜
		假设银行完成约束控制客户的支票账号和存储账号 分别为 100 200 美元事务设置二个余额
		事务T1读取二个 并进行完整性约束从储蓄取货200 每个事务在快照上进行完整性约束的检查
		如果同时执行任何一方存取款的余额为100 取不违反完整榆树 不存在冲突更新 都可以提交
		但是在提交后面 余额为-100 违法了 不可能储蓄在串行事务中
		* 数据库强行执行完整性约束 不能再快照上检查否则二个并发事务插入主键相同的记录 或者一个事务
		插入外键相同的值 另一个并发事务删除该值

* 插入删除操作与谓词读
	* 事务处理数据项不仅要求访问在的数据项write read
	还可以创建新的数据项 删除数据项
	* delete(Q) 
	* insert(Q) 插入新的数据并赋予Q一个初始值
* 删除
	* delete如何影响并发事务 如何与另一个指令发生冲突
	I分别是T的指令 连续出现在调度S中  I=delete(Q)
		* I = read(Q) 冲突 I出现在I之前 事务T出现逻辑错误 反之事务T可以执行
		* I = write(Q) 冲突 I出现在I之前 事务T出现逻辑错误 反之事务T可以执行
		* I = delete(Q) 冲突 I出现在I之前 事务T出现逻辑错误 反之事务T可以执行
		* I = insert(Q) 冲突 数据项Q在执行前不存在 则出现逻辑错误 如果在之前则没有逻辑错误
		如果Q在执行I之前存在 会出现逻辑错误 反之不会
	* 总结
		* 在二阶段封锁协议 数据项可以删除之前碧玺在数据上请求加排他锁
		* 在时间戳排序协议之下补习执行write操作继续测试 假设T发出delete
			* 如果TS < R-timestamp T将数据项Q值满足 TS(T1)>TS(T1)读取
			* 如果TS < W-timestamp 满足 TS.TS的事务已经写过Q delete被拒接 T回盾
			* 否则执行delete操作

* 插入
	* Insert(Q)给数据项Q赋值 并发控制处理write操作那样处理insert操作
	* 二阶段封锁协议 如果T执行insertQ操作就 就创建在数据项Q赋予T排他锁
	* 在时间戳排序协议下 如果T执行insertQ操作 R-timestamp W-timestamp 设置为TS

* 谓词读和幻象现象
	* T并没有发完共同元组 但是相互冲突 存在幻象元组冲突
	如果并发控制在元组级颗粒上进行 系统不能防止出现可串行化调度 
	这种现象称为幻象现象
	* 一个事务利用索引插叙 Dept_name 因此不读取其他联系的任何元组
	这个问题就是谓词读导致的有共同解决方法
	* 为了防止幻象现象 运行T事务阻止其他事务在关系上创建 搜索的那个新的元组
	并阻止一个元组更名

* 索引封锁技术
	* 封锁对应关系的一个数据项或者封锁整个索引导致并发性降低 在关系中插入不同
	元组的二个事务不能并发执行 可以使用索引封锁及技术
	* 避免封锁整个索引 在关系中插入元组的任何事务必须在关系上维护每个索引相关的信息
	* 每个搜搜吗增加一个叶节点关联 插叙使用一个或者多个索引来访问关联 插入操作必须在 关系索引中加新的元组

* 索引封锁协议
	* 每个关系至少有一个索引
	* 只有子啊关系一个果子多个索引找到元组后 事务在能访问关系上的这些元组
	全表烧苗看成一个索引上的叶节点扫描
	* 进行查找 的事务必须在 访问索引的叶子节点上获得共享锁
	* 没有更新关系r上的索引索引之前事务不能 插入 删除或者更新关系r中的元组 事务必须获得DML索引
	叶节点上的排他锁 对DML做出操作的是更不的搜搜码值的叶子节点
	* 元组照常获得锁
	* 遵循二阶段封锁协议

* 索引结构中的并发
	* 由于索引访问的频繁导致低并发度 事务在二次索引查找期间发现索引结构发生变化
	是可以接受的 索引查找返回正确的元组集合 
	* 只要维护索引的准确性 对索引进行非可串行化的并发存取是可以接收的
	* 处理B* 树技术基于封锁的机制 不采用二阶段封锁也使用树形协议  

* 蟹行协议	
	* 查找一个码值 先使用共享模式锁根节点 沿树下遍历 在子节点获得共享锁
	在子记得获得锁以后 是否父节点上的锁 重复该过程到叶几点
	* 插入或者删除 
		* 采区查找系统方法找到叶子节点 只获得是否共享锁
		* 排他锁封锁该节点 并插入或者删除码值
		* 分裂节点或将兄弟节点合并 抽象分配码值 封锁父节点 完成操作释放锁
		如果需要分裂合并重新分布码值 该协议保留父节点 锁 

* B-link 树
	* 避免获取 另一个节点锁的时候还占用一个节点的锁获得哼更多的并发性
	每个节点维护一个向右的兄弟节点的指针 不惜的 分裂进行查找的时候找到右兄弟节点
	* 查找
		* 访问之前必须加共享锁 非叶子节点的锁应该在B树其他任何节点发出锁请求释放
		如果节点分裂查找同时发生 搜索码值不能位于查找过程访问的节点代表的值范围内
		搜索码的值在兄弟节点代表的访问内找到该兄弟节点
	* 插入删除
		* 查找规则 共享锁设计为排他锁然后插入或者删除 遵循二阶段封锁协议
		避免幻象
	* 分裂
		* 如果事务使一个节点分裂 设置源节点和新结点产生右兄弟指针
		事务是否原点的排他锁 然后发出对父节点排他锁的请求 以便插入新节点的指针
	* 合并
		* 执行删除的时候 一个节点的搜索码值太少 将合并的节点加上排他锁 
		一旦二个节点合并 发出对父节点排他锁的请求以便删除被删除的节点
		事务释放合并的节点锁 

## 系统恢复
> 计算机发生故障就可能丢失信息 因此数据库系统预先采取保存超市 保证发生故障
也保存事务的原子性和持久性恢复机制是数据库不可缺少的部分 故障发生前的意志状态 
必须提供高可用性 时间缩短到最短

* 故障的分类
	* 事务故障 
		*  逻辑错误 
			* 事务由于内部条件无法继续执行 内部条件非法输入 找不到数据 语出或超出资源限制
		* 系统错误
			* 系统进不良状态如死锁 结果事务无法正常执行但是该事务可以在以后的这个时间段执行
	* 系统崩溃
		* 硬件故障或数据库软件或者操作系统洞导致易失存储器内容的丢失
		并使事务处理停止 非易存储器然后无损
	* 磁盘故障
		*  数据传输的过程中磁头的损害或造成磁盘块的损坏导致内容的丢失
		其他磁盘上数据拷贝或者三介质备份可以从故障恢复 对内存有什么影响
		保证数据库一致性 事务的原子性 恢复算法
			* 正常事务处理采取的超市保证足够的信息用于故障恢复
			* 故障后 数据库内容恢复到保证数据库的一致性事务 原子性的状态

* 存储器 
	* 易失性存储 volatile srotage 
	* 非易失存储器 nonvolatile storage 
	* 稳定存储器   stable storage 

* 稳定存储器实现
	*  在多个 非易失存储器存储介质(磁盘上)独立的故障模式复制所需的信息保证数据发生故障不会破坏所需的值
	* RAID系统保证单个磁盘的故障 不会导致数据的丢失 最简单的RAID形式是磁盘镜像
	(发生在数据传输过程中) 不同磁盘上为每个磁盘块保存二个拷贝 代价低性能差一点
	* RAID系统不能防止灾难而导致的数据丢失 许多系统是归档备份存储磁盘上并转移
	来防止 但是磁盘不能连续不断移至其他地方 最安全的为稳定的存储器每个块保存一份拷贝
	在本地远端都进行备份

* 数据传输的结果
	* 成功完成 传输的信息安全到达
	* 部分失败 传输的过程发生故障 块有不完整信息
	* 完全失败 传输过程中故障发生的足够早 目标块完整无缺

* 数据传送故障的方式 
	* 系统能调整并回复过程为一致状态 系统Wie每个逻辑数据块维护
	二个数据块 如果是镜像的在同一滴滴 如果远程备份 一个在本地 另一个远程节点
	* 信息写入第一个物理块
	* 当第一次写入完成 将系统信息写入第二个物理块
	* 第二次完成 输出才完成
	* 对于每个块的发生古筝可能拷贝相互不一致在恢复过程对于每个块
	要检查拷贝的错误并且系统 如果有错误用另一个块代替这个的内容
	都没有凑无 但内容不一致 使用值替换

* 数据访问
	* 数据库系统常在非易失存储器 在任何时间只用数据库的内容在主要内存中
	分成 块的定长存储单位 块是在磁盘传送的单位 波爱护多个数据块
	* 事务有磁盘向主内存输入信息 然后将信息输出回避盘 位于磁盘上块成为物理块
	临时位于主存的块成为缓存块 内初中用于临时存放成为磁盘缓存区
		* 磁盘块的移动
			* input传送到物理块B至主存
			* output传送到缓存块B至磁盘 并替换磁盘上的物理块 
* 日志记录
	* 事务标志是执行write操作的唯一标识
	* 数据项表示 数据项是唯一表示 在磁盘上的位置
	* 旧之 数据项写前的值
	* 新值数据项写后的值


## 并行数据库
> 在共享内存体系结构中所用处理器共享一个公用的主存储器和磁盘在共享
磁盘体系中 处理下有独立的主存储器 但共享的磁盘在无共享的体现中处理不共享的
处理器 也不共享磁盘层次的体现中有多个节点中心节点不共享主存储器 每个节点的内部的共享的体系结构

* I/O并行
	* 将关系划分到多个磁盘上缩减来自磁盘上对关系所需的时间 通常使用的是
	水平分区在水平分区中关系的元组划分到多个磁盘上每个元组在一个磁盘上

* 划分技术
	* 轮转法 对关系进行随扫描将第i个元组标记为D的磁盘上 保证元组在多张磁盘上的
	平均分布 每张磁盘上有大致相同的数目元组
	* 散列划分 将关系模式中一个或多个数据指定为划分属性 选址为 [0 1 n-1]的散列函数
	给每个元组划分属性进行散列
	* 范围划分 给每张磁盘分配联系的数据值的访问元组 选定一个划分属性和划分向量

* 偏斜处理
	* 划分一个关系时候采用不是轮转的其他技术元组的分布可能会发生偏斜
	* 属性值偏斜
		* 在多个元组互粉属性取相同值的元组划分到同一分区中
	* 划分偏斜
		* 不存在属性偏西 划分也存在负载不均衡
	* 即使很少的偏西也导致性能的显著降低随着并行的提高偏斜会发生更严重的问题
	元组得到的加速比例不均 导致损失更大

* 平衡的范围划分向量
	* 通过排序的方法来构建 关系按照属性划分进行排序 然后对关系排序进行扫描
	通过关系的排序进行扫描 没读取该关系的 1/n 将下一个院子官方属性加入划分向量
	* Oracle Rdb 系统是执行查询并的数据项系统的实列

* 查询并行
	* 不同查询事务并的执行 可以提高事务的吞吐量 单个事务的响应时间不会び事务隔离的方式运行
	更快 查询并行主要处理是事务上的扩展 
	* 查询并行是数据库支持的更加复杂 确保是最小的问题称为高速缓存一致性的为题
	单个查询执行有不同的并行方式
		* 操作内并行
			* 并行执行每个运算 排序 选择 投影 联系来加快查询的数据
		* 操作的间并行
			* 执行一个查询表达式中多个不同的运算来加快一个查询处理器的速度
### 操作并行
> 流水并行 独立并行

* 流水并行
	* 减少数据库插叙处理计算点的重要途径 未完全输出元组
	集合之前 运算A的输出元组被运算B使用 不必在磁盘中写中间结果
	将运算进行下去
	* 少量处理器的时候有效的 扩展不好 加速比低

* 独立并行
	* 查询表达式不依赖运算并行的执行
	* 提供较高的并行度 高度并行中没用


## 分布式数据库
> 松散耦合站点组成不共享物理部件 可以实质上独立程度 

* 同构和异构数据库
	* 同构分布数据库系统中所有站点使用系统的数据库管理系统软件
	共同虎坐处理用户请求 本地张鼎分区部分蜘蛛侠 为事务处理在多个
	站点进行 

* 异构分布式数据库
	* 不同站点使用不同浓缩和不同数据库管理软件 站点之间彼此并不了解
	合作处理的事务过程中 尽可能的提供有效功能 软件的差异为处理多个事务的一个障碍


* 分布式数据存储
	* 复制 维护关系相同的副本将每个副本存储在不同的站点上
	* 分片 关系划分成几个分片将每个分片存储在不同站点上

* 数据复制
	* 可用性 包含关系r的站点发生故障 在另一个站点找到
	* 增加并行度 事务执行的站点发现需的数据机会就会增大
	* 增加更新开销 保证所有的副本是一致的

* 数据分片
	* 关系是分片的划分成诺干个字节 构建的信息能重新构造
	* 二种不同方案用于对关系分片 水平分片和垂直分片 

* 水平分片
	* 关系r划分为多个字节 r1 r2 rn包含足够的信息构造原关系 不同方案
	必须属于一个分片 在需要的时候构建原始关系
	* 水平分片可以定位为整个关系上的一个选择 使用谓词来划去分片
* 垂直分片
	* 使用人任何超码模式R中加入成为tmpl-id 的特殊属性通常比较方便
	* 二种类型可以应用到单个模式行 对关系水平划分得到可以进一步使用垂直划分

* 透明性
	* 分布式数据库系统的永不不需要知道数据的物理位置在特定的站点上如何处理
	该特点成为数据透明性
	* 分片的透明性
		* 不知道关系是如何分片的 
	* 复制的透明性
		* 每个数据对象逻辑上是唯一的分片系统wield提供系统或者数据的可用性复制对象
		不必关系数据对象的复制 て不必关系副本存放的位置
	* 位置的透明性
		* 数据的物理位置 只要提供用户事务的数据标识符 分布式数据库系统能找到任何数据

* 分布式事务
	* 对各种数据的访问通过事务来完成使用必须保持ACID特性 
	* 局部事务 子啊局部数据库中访问更新的数据事务 
	* 全局事务 多个局部数据库服务更新数据的事务

* 系统结构
	* 事务管理器 管理访问存储在局部站点中的数据事务 (或子事务的执行)
	每个事务既可以是局部事务也可以是全局事务
	* 事务协调器 协调在站点上各个事务的执行

* 事务管理
	* 维护一个用于恢复的日志
	* 参加一个合适的并发控制方案 协调在站点上执行事务的并发执行
	* 启动时的执行
	* 将事务分成子事务 并将只是我分派给合适的站点执行
	* 协调事务的中止 导致事务在所有站点的提交上都中止

* 提交协议
	* 二阶段提交
		* 阶段1 将纪录加到日志中并强制写入稳定存储器上 prepare 消息
		发送到执行T的所用站点上 受到这个信息站点事务管理器确定是否属于提交
		T中的部分 
		* 阶段2 C收到所用站点对prepare 消息的回答 发送经历了一段预定的时间间隔 
		确定事务提交还是中止 如果接收到所有的时间间隔 确定是事务提交还是中止
		*  向协调器发送到redy 消息之前 执行T的站点可以在然后时候无条件中止 一旦发出消息
		站点上事务将成为就绪状态 在效果上 redy 消息是站点做的承诺 事务的拥有必须保持到事务结束
		* 提交事务需要一致 至少有一个站点回答 abort T 事务T决定了 协调站点进行消息确定
	* 三阶段提交	
		* 二阶段协议的扩展 特定假设避免了阻塞的问题 不发生网络划分不超过k个站点发生
		故障 有一个正在确保提交决定会保护
		* 网络划分会超过k个站点故障的错误导致 网络格的阻塞

* 事务处理的可选择模型
	* 持久消息 发送消息的事务提交 不管是否反正故障 保证传送的结果恰好一个 
	如果事务中止 持久消息不传送 
	* 事务上故障会导致本地数据访问的阻塞 因此很少有株洲机构会支持在组织救过之外发生事务的二阶段提交
	持久消息在之跨越株洲机构事务扮演重要的角色

* 持久消息的实现
	* 发送站点协议 
		* 事务希望发送持久消息的时候在专有关系写一条包含包含消息的记录
	而不是直接外向发送消息 被赋予一个唯一的消息标识符
	* 接收站点协议
		* 站点接到消息没有出现在关系中唯一的消息运行检查出重复 事务提交之后
		或者消息出现在关系时候 接收站点发回一个确定

## 基于云的数据库
> 云计算(cloud computing) 开始命名为软件既服务 (software as a service) 提供驻扎
在机器上特定的 可定制的应用程序 客户可以与云计算供应商达成协议来过的特定能力或者特定数量的集群
比如存储服务 地图服务已经 web程序接口访问的其他服务

* 云上的数据存储系统
	* 基于云的数据存储系统支持表示复杂的数据xml 另外支持Javascript对象表示
	雨多接收JSON表示辅助的数据 提供了一条激励包含的属性类型的灵活性
	* 云数据存储系统的核心的基于二个基本函数 用于存储相关码的值 pot(key value)
	利用搜索特定关联的存储值get(key)
	* 划分表块 服务器的映射信息存放的体系结构可能由变化 Bigtable没有独立的路由器
	划分存放信息的在google文件系统中  
	

* 基于云数据库的挑战
	* 访问在物理计算器上的数据是因为虚拟机拥有该数据能控制的数据项物理位置
	* 获得远程数据上的封锁
	* 通过二阶段提交确定原子性事务的提交
	* 数据物理层的控制由供应商控制并不是客户 数据存放的位置就同喜代价来说不是理想的
	导致大量远程封锁请求和虚拟机中间的锻炼数据传送 搞笑的查询优化器能准确的度量操作代价
