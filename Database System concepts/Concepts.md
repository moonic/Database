# Database System concepts 
> 对数据 存储管理 处理和维护的软件系统
 
* Database Mangement System DBMS
	* 关联的数据集合好一组访问数据的程序组成
	* 提供发布高校的存储数据项信息的途径
	* 信息的存储结构定义 安全保证 避免异常产生

* File Save Data
	* 数据杂糅不一致
		* 同种信息 无法分辨 同名等
	* 数据访问困难
		* 新的需求增加 功能列表 如何访问
	* 数据孤立 
		* 数据分散不同文件中 格式不同
	* 完整性
		* 数据的每个值都满足特定的约束
	* 原子性
		* 银行的存储 账户永远不为零
	* 并发访问异常
		* 一个行为同时并发进行
	* 安全性
		* 数据存储的安全性访问，并不能访问所有数据


* Data View
	* 相互关联的数据组成一组用户可以访问修改的数据集合 

* Data override
> 可用的系统必能高效的检查数据 简化用户的操作

* 物理层
	* 数据是如何存储
* 逻辑层
	* 数据存储什么数据 存在如何的关系 保护数据的独立性
* 视图层
	* 提供用户访问数据的交互视图


 type instruclor = record
 	ID : char(5)
 	Name : char(5)
 	Dept_name : char(5)	
 	salary : number(8,2)
 	end;

* 定义了了4个字段记录 每个字段记录有一个字段名所属的类型
	* deotment Dept_name buidding budget

* 物理层
	* 一个字段的记录可以被描述层联系存储组成的存储块
* 逻辑层
	* 记录间的相互关系
* 视图层
	* 一组应用程序
---

## 实列和模式
> 时间的推移 信息被插入删除 存储在数据库中的称为 实列
数据库总设计成为数据库模式 不同层在不同模式下的设计成为


* Data Model
> 描述 数据 联系 语言 以及 一致性元素概念工具的集合

* 关系模型
	* 表的集合来表示数据和数据间的关系
	* 基于纪律模型的一种

* 实体 联系模式 E-R
	* 实体基本对象以及对象构成
	* 对象的以及市区或者一个问题
	* 用于数据库设计

* 对象的数据模型
	* 面向对象数据模型
	* E-R模式 增加封装方法 还是对象表示等标识概念扩展

* 半结构化数据模型
	* 运行系统数据类型的数据项含不同属性集的定义
	* xml 被广泛的表示

* 数据库语言
	* 数据库系统提供的语言来定义数据库模式 以及数据操作系统鱼鱼
	* 操纵语言 DML
		* 查询 select *from name
		* 插入 insert into table_name values()
		* 修改 delete from table_name xx where 
	* 过程化DML  指定数据以及如何获得数据
	* 声明化     用户知道数据但是不申明
* 数据定义语言 DDL
	* 数据存储定义
	* 满足一致性约束
		* 成约束 
			* 每个属性对弈一个肯的取值构成的成
		* 参照完整性
			* 关系给定属性集上的取值存在
		* 断言
			* 成约束是断言的特殊形形式
		* 授权
			* 不同的用户在数据库中的数值运行不同访问类型
			* 读授权 修改授权 更新授权

* 关系型数据库
> 关系型模型 包括数据操作语言 SQL语言

* 表
	* 每个表有多个实列 每个列有唯一的名字
	* 关系型模型是纪律模型的一个实列
	* 结构固定格式id记录 每个表一种特定类的记录

* 来自应用程序的数据访问 （DML由宿主入）
	* 提供的程序接口 取回结果
	* 扩展宿主 衣服 嵌入DML调用 DML 预编译器


### 数据库设计
>管理大量信息，作为企业行为的一部分 粳稻信息服务

* 设计过程
	* 选择数据模型 概念设计
		* 包括哪些数据 如何组织到表存放到表中
	* 功能性说明 
		* 数据上的各种事务  功能满足需求
	* 逻辑设计模型 
		* 映射到数据模型上用于特定是为了设计模式

* 实体联系模型 E-R
	* 通过实体数学集合来描述
	* 各个实体之间的联系
* 规划化
	* 生成关系模式集合 存储信息不必要杂糅能心意的搜索数据
		* 适当的范式模式 函数依赖

---

### 数据存储和查询
> 数据库分成不同的模块 每个模块完成一个功能 分成存储管理器
和查询处理部件

* 存储管理器
	* 权限以及完整性管理
		* 是否完整约束 用户权限
	* 事务管理器
		* 事务一致性
	* 文件管理器
		* 磁盘的空间分配
	* 缓存管理器
		* 磁盘读取到内存 那些数据缓存到内存中
	* 数据文件
		* 存储数据本身
	* 数据字典
		* 数据库结构元数据 数据库模式
	* 索引
		* 数据项快速访问

* 事务管理
	* 原子性 一致性 持久性
	* 完成单一逻辑功能的操作集合

* 数据挖掘与信息检查
	* 数据文件 不知道分析大型数据库并从中找出有用的模式过程
	也成为集群学习 统计分析 从数据寻找规则和模式
	* 可以已知信息变量来预测输出
	* 数据处理编程时候算法的格式 找到新奇有用的模式 给定一个数据库
	* 商业使用连接数据来支持对业务更好的决策
	* 大型企业的不同决策要在各种不同的数据上高数的执行查询
	建立了 数据仓库 多个来源收集数据激励统一的模式
	* 文本数据爆炸的增长（和关系数据库中结构化数据的不同） 信息检查也车位

* 特种数据库
	* 应用领域受到关系模型的限制 开发了 数据模型来处理这些领域的问题

* 基于对象的数据库
	* 面向对象程序设计 导致面向数据模型的在
	* E-R的扩展 增加了 封装 方法 函数对象的表示 对象便和信息封装
	* 对象 关系数据模型 扩展了关系模型


* 半结构化数据模型
	* 允许系统数据有不同属性数据的说明 
	* xml语言的设计 为了文本数据增加标签信息

---


# 关系模型
> 商用数据处理成为主要的数据模型 简化了编程的工作

* 关系数据库的结构
	* table的集合组成 每个表有唯一的名字
	* 关系用来代指表 元组代指行 属性 是列
	* 用关系实列来表示关系的特定行
	* 对于关系的属性存在一个存取值的集合成为该属性的（域）
	* null是一个特殊值

* 数据库模式
> 数据库模式是数据库的逻辑设置，数据库实例是数据库中的快照

* department(Dept_name,building,budget)
	* 关系模式是将不同的关系元祖联系在一起的方法
	* 就是表的 标的

* 码 key 
	* 区分关系不同元组的方法，使用属性来说明
	* 一个元祖的属性必须唯一 区分元元组的
	*一个关系没有二个元组所在的属性上取值相同

* 超码 superkey
	* 一个欧多属性的集合 唯一标识元码
	* 列如 instructor的ID属性可以区分元组
	* ID 和name是组合关系 instructor一个超码 最小超码称为后选码

* 主码 primary key
	* 必须作为唯一区分
	* 从不 极少变换的值
	* 参照完整性约束 referential integrity constraint

* 关系模式 家里在表的集合基础上 对表进行查询 插入元组修改更新元组
* 关系的超码是一个 数学的集合 取值保证唯一失败
* 模式图 数据库关联关系的图形化表示

--- 

# SQL语言
> IBM开发的叫做sequel发展到现在 结构化化查询语言
ISO 发布标准 

* 组成部分
	* 数据定语语言 DDL
		* 定义关系模式 删除修改的命令
	* 数据操作语言 DML
		* 查询信息 插入元组 删除 修改元组的能力
	* 完整性
		* 定义的完整性的约束
	* 视图定义
		* DLL包括定义视图的命令
	* 事务控制
		* 开始 结束事务的命令
	* 嵌入式SQL 动态SQL
		* 如何嵌入通用编程语言
	* 授权
		* 对视图的访问权限命令

* SQL 数据定义
	* 每个关系模式
	* 每个属性的取值
	* 完整性约束
	* 关系维护的索引集合
	* 关系的安全权限信息
	* 关系物理存储

* DML
	* insert 将数据插入到关系中去
	* delete 删除元组
	* drop 除去关系
	* alter 增加 属性

* select 列出需要属性
	* from 访问关系列表
	* where 在from 取谓词

* 事务
	* 查询或更新语句的序列组成 
		* commit work 提交当前事务
		* rollback work 回滚
* 完整性约束
	* not null 非空
	* unique
	* check 谓词
	* primary key 主键约束
	* 外键约束

* from定义在句子的笛卡尔积 使用集合理论来定义
* 迭代过程来理解 from 字句结果关系产生的元组
for each 元组 t in 关系 r1
	for each 元组 t2 in 关系 r2

		* distinct 出去重复 
		* all 显示不出去重复
		* join  自然连接

--- 

## 关系代数
> 过程化长训语言 包括一个运算的集合 以关系为输入产生新关系作为结果

* 关系代数的运输分为
	* 基本运算
	* 附加运算
	* 扩展运算

* 关系的基本运算结果有
	* 选择 投影 并 集合差 笛卡尔积 更名
	* 其他运算
		* 集合教 自然选择和复制

* 基本运算
	* 选择 投影 更名 称为一元运算 对一个关系进行运算

* 选择 select 满足给定为谓词的元组 sigma（α）表示选择
	参数关系 α 括号中 
	* 选择关系 instructor 中联系元组 写作
		* αdept_name = physics(instructor)

* 投影运算
	* 假如累出所有 ID name salary 不关系 Dept_name 
		* π_ID,name,salary (instructor)
	* 关系集合运算
		* Π_name (α_dept_name = physics(instructor))
	* 将关系代数组合成关系代数表达式
		* 如同算数表达式 + - 组合一样

* 并运算 r∪s
	* 关系必须同元 属性数目相同
	* 对于 i，r 属性域 必须和 s的i个 属性相同

* 集合差运算 -
	* 相融的关系运算
	* 关系必须同元 属性相同

* 笛卡尔积运算 r1xr2 
	*  提出命名机制来区别属性的关系 附加在属性上
		* α_dept_name = phyiscs - (instructor x teaches)
	* 将 instructor 元组 和 teaches 元组 属性联系

* 更名运算
	* 关系代数表达式结果是没有引用的名字 
		* ρ_x（A1,A2,...A_n）

* 关系代数的形式化定义
	* 数据库中的一个关系
	* 常量关系
	* 交 并 补 差 积

* 扩展关系代数运算
	* 广义投影
		* 投影列表使用算数运输费 函数等进行扩展
		* π_F1,F2...Fn(E)
	* 聚集
		* 聚集函数 
			* 输入值一个汇集 使用对值集合使用
				* sum 汇聚 {1,1,3,4,4,11}
			* 多重集
				* 同一个值出现多次

## 元组关系演算
> 写关系代数表达式 产生了查询你结果过程序列 能生成查询答案
元组关系是非过程化的查询语言 只描述信息 不给出过程

* 查询实列
	* 工资 8000 以上的 ID name Dept_name salary
		* 只需要ID的属性 不是关系所有的属性 使用元组演算

* 表达式的安全问题
	* 元组运算表达可能产生一个无限的关系
		* 为了对元组关系进行限制 引入了元组关系式 P的域

--- 


## 数据库设计
> 构建一个数据库 包括设计数据库模式 访问更新的程序 
已经数据访问的安全模式 用户在需求设计扮演一个中心角色
主要描述数据库模式设计

* 设计选择
	* 杂糅
		* 重复信息存储 信息的拷贝会变的不一致
	* 完整性
		* 实体中没有对应的关系 如何设计

* 实体-联系模式 E-R Model
>代表数据库去哪聚逻辑结果的企业模式实现的

* 实体集
	* 实体
		* 可区别所用其他对象的事务 或者 对象 使用唯一标识
	* 相同类型具有相同性质的实体集合
		* 实体集不必互不想交
	* 通过一组属性来表示 每个属性都有确定的值

* 联系集
	* 联系 多个实体的相互关联
	* 联系集 相同类型类型的集合 n>=2 实体集合上的数字关系
	* 实体集 之间的管理称为参与
		* 联系实例 命名实体同一个关联
	* 联系也具有描述性 实体与属性相联系起来
	* 作为联系描述属性的列子 考虑实体student section参加的联系集
	  可以用一个数学来记录学生的到课率
	* 给定联系必须是参与实体表示的 不必使用描述属性
		列子 一个教室作为特定学生导师日期建模 使用参与实体是无法
		唯一标识的
	* 二元联系 
		* 大学开展实体联系集 project 有多个学生老师参加
		* 参与实体集的数目成为联系集的度 degree 二元为2
* 属性
	* 每个属性有一个可取值的集合成为 属性的域 或者值集
	可以是特定长度所用文本字符串的集合 
	* 实体集的属性是将实体映射到域的函数 一个实体有多个属性
	每个时下可用一组 属性 数据值来表示

* E-R模型属性划分
	* 简单的复合属性 简单时下不能被划分成更小的部分
		* 复合属性能划分成更小的部分 (其他属性)
		* 复合属性可以有层次的 多次分拆
	* 单值和多值属性 一个特定实体只有单独的值
		* 单值 对特定的学生实体一个Student_ID独一一个ID
		* 多值 不同的教室有不同数量的电话
	* 派生属性 从别的关系实体派生出来 教师实体有属性表示指导多少学生
	可以通过统计学生实体 数目来得到这个关系

* 约束
	* 映射基数约束 实体通过类型集关联的实体个数
		* 一对一 
		* 一对多
		* 多对多
	* 参与约束
		* 实体都参与到联系集的至少一个联系中
			* 实体集 在联系集中的参与成为 全部的
			* 参与只是部分的称为部分参与集

* 实体联系图
	* 表示数据库的全图逻辑
	* 设计问题
		* 新增加的属性和实体集 是用属性还是用实体
		* 对象被描述为实体集还是联系集 并不是容易的
			用实体集还是联系集
		* 父母有一个孩子 可以记录母亲而不知道父亲 二元还是n元联系集

* 扩展的E-R特性
	* 特化
		* 实体集包含子集的实体区别实体集的其他实体
			* 实体集的 persion 
				* employee
				* student
		* 实体集是否可以是于多个特化实体集必须特化一个
		成为重叠特化 后者称为不持久特化
	* 概化
		* 实体集到不同层次的实体子集细化代表 自顶向上进行
		* 多个共同特征综合成高层实体集合 开始标识
		* 高层与低层的实体集被称作超类 和子类
			* persion 与 employee student
* 属性的继承
	* 特化和概化产生的特性是属性的继承
	* 高层实体的关联所用属性适用于低层实体
	* 底层实体特有的性质适用于特定实体集

* 概化的约束
	* 条件定义的 
		* 在条件定义的低层实体 成语之歌确定基于实体是否满足特定的条件与谓词
	* 用户定义 
		*用户定义的低层实体表示通过成语资格来限制的数据库用户实体派个实体集
	* 不想交 
		* 不想交约束要求一个实体至多一个低层实体集
	* 重叠 
		* 通过实体同时属于一个概化多个低层实体集
	* 聚集
		* 联系集属性可以合并到联系集中

## 关系数据库设计
> 如何生成一组关系模式 满足实弹的设计范式

* 更大的模式
	* instructor deptartment 对弈的关系进行自然连接的结果
	* 元组的预算数据统一 每个预存数据存储一次
	* 无法直角表示一个实体的信息 

* 更小的模式
	* 发现实体的属性的信息重复 分成更小的设计模式
	* 观察导出的规则(函数依赖)模式 找到正确的分解
	* 利用分组插常生的元组 有损分解 无损分解 

* 原子域和NF1
	* E-R模式 运行实体的连续集的属性具有程度的子结构
	* 但是设计表的时候消除子结构对 于组合的每个指数下作为本身属性
	* 多值属性每个项创建一条元组

* 一个域是原子的 该域不可分成为NF1

* 使用函数依赖继续分解
> 关系是否该分解 基于函数依赖的概念
	* 关系模式是一个属性集 并非属性是模式
	* 属性是超码 特殊关系模式

* 码和函数依赖
	* 实体建立模式 数据存在各种约束
	* 实体的约束转化 成码，或者定义的函数依赖
		* 判定关系的实例是否函数依赖集
		* 合法关系集 上的约束那些关系实例

* Boyce-Codd NF
	* 消除基于函数依赖的杂糅
		* a -->b 是平函数依赖
		* a是 模式R的超码
	* 构成giant设计模式的关系集合中每个模式属于BCNF
	* 关系二方属于属性的函数依赖
	* 一般规则 a-->b a不是b的超码
		* a∪b
		* (R - (b-a) )
	* 最后保持BNCF模式的集合
* BCNF 和保持依赖
	* 在有些情况下BCNF的分解会导致函数依赖的高效检查
		* 大学课程为多对一提出 但是教师只能是的单个关联
		* 设计为实体联系依赖
* 第三范式
	* BCNF 平凡依赖如 a-->b a为一个超码
	* 具有函数依赖的 模式属于第三范式
	* 某些 BCNF  不允许俄的函数迎来 在3NF是允许的

* 函数依赖理论
	* 函数依赖集的闭包
		* 定义模式上的函数依赖集在其他函数模式上也存在
		称这些函数依赖 F逻辑蕴含

* 逻辑蕴含的函数依据
	* 自反律 b∈a a-->b
	* 增补律 a-->b 成立 为r的属性集 ra-->rb成立
	* 传递律 a-->b b-->r 成立则a-->r
	* 合并律
	* 伪传递律

* 属性的闭包
	* a--->b 称为属性b被a函数确定(functionally determine)
	* 集合a是否为超码 计算a函数的属性值
		* resul:= a;
			repeat
				for echo 函数依赖 b-->in F do
					begin
						if b∈resul then resul := resul∪r;
					end
				untll (resul不变)

* 正则覆盖
	* 关系模式上有函数依赖F在关系执行更新 保证不破坏任何函数依赖
	如果破坏了函数依赖 系统必须回滚更新操作
	* 任何函数依赖属性不改变 函数依赖集的闭包则属性是 无关属性
		* A∈a F蕴含 a-->b ∪(a-A)-->b A在a中无关
		* A∈a F蕴含 a-->b ∪a-->(b-A) A在b中无关

* 无损分解
	* 一个关系模式 上的函数依赖 分解关系模式 没有信息损失
	称该分解为无损分解
		* Select * from (select R1 from r) natural join (select R2 from r)
		* π_r1 ↔ π——r2 = r
	r投影到R1和R2上计算投影结果是自然连接 称为有损分解
		* R1 ∩ R2 --> R1 
		* R1 ∩ R2 --> R2

* 分解算法
	* 使用适当的NF设计算法 BCNF 3NF 对应的算法

* BCNF 分解
	* 检查观赏是否属于BCNF F是繁重的任务 描述判定关系
	是否属于 不过不属于能被分解属于的则称为BCNF算法
	* 判定方法

